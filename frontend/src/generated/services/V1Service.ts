/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { AreAllOptional, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, Updater } from "@tanstack/query-core";
import type { DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface V1Service {
    getAuthLogin: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthLoginParameters | void): ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLoginError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthLoginParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, TPageParam, GetAuthLoginError>): Promise<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthLoginParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, TPageParam, GetAuthLoginError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthLoginParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, TPageParam, GetAuthLoginError>): Promise<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, GetAuthLoginError> | void): Promise<GetAuthLoginData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, GetAuthLoginError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, GetAuthLoginError> | void): Promise<GetAuthLoginData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void)): OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>,
            data: GetAuthLoginData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void)): GetAuthLoginData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void)): QueryState<GetAuthLoginData, GetAuthLoginError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthLoginParameters | ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | void): QueryState<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>, GetAuthLoginError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthLoginSchema, GetAuthLoginParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthLoginParameters, TMeta, TSignal> | void), client?: (schema: GetAuthLoginSchema, options: {
            parameters: GetAuthLoginParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthLoginData, GetAuthLoginError>>): Promise<RequestFnResponse<GetAuthLoginData, GetAuthLoginError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthLoginParameters | ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, updater: Updater<NoInfer<GetAuthLoginData> | undefined, NoInfer<GetAuthLoginData> | undefined>, options?: SetDataOptions): Array<GetAuthLoginData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthLoginParameters | undefined) | ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, updater: Updater<NoInfer<GetAuthLoginData> | undefined, NoInfer<GetAuthLoginData> | undefined>, options?: SetDataOptions): GetAuthLoginData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthLoginParameters | void): ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogin.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLoginParameters, TData = GetAuthLoginData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthLoginData, GetAuthLoginError, OperationInfiniteData<TData, GetAuthLoginParameters>, ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLoginData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogin.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLoginParameters, TData = GetAuthLoginData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthLoginData, GetAuthLoginError, OperationInfiniteData<TData, GetAuthLoginParameters>, ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLoginData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthLoginTotal = qraft.v1Service.getAuthLogin.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthLoginResults = qraft.v1Service.getAuthLogin.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLoginResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthLoginCombinedResults = qraft.v1Service.getAuthLogin.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLoginCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthLoginSchema, GetAuthLoginParameters, GetAuthLoginData, GetAuthLoginError>>, TCombinedResult = Array<UseQueryResult<GetAuthLoginData, GetAuthLoginError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthLoginData, GetAuthLoginError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthLoginParameters | void): ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogin.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthLoginParameters, TData = GetAuthLoginData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthLoginData, GetAuthLoginError, OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginData, ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLoginData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthLoginSchema, GetAuthLoginParameters, GetAuthLoginData, GetAuthLoginError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthLoginData, GetAuthLoginError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthLoginData, GetAuthLoginError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthLoginError | Error>;
        schema: GetAuthLoginSchema;
        types: {
            parameters: GetAuthLoginParameters;
            data: GetAuthLoginData;
            error: GetAuthLoginError;
        };
    };
    getAuthCloseWindowMessage: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthCloseWindowMessageParameters | void): ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): UseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, TPageParam, GetAuthCloseWindowMessageError>): Promise<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, TPageParam, GetAuthCloseWindowMessageError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthCloseWindowMessageParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, TPageParam, GetAuthCloseWindowMessageError>): Promise<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | void): Promise<GetAuthCloseWindowMessageData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | void): Promise<GetAuthCloseWindowMessageData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void)): OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>,
            data: GetAuthCloseWindowMessageData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void)): GetAuthCloseWindowMessageData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void)): QueryState<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthCloseWindowMessageParameters | ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | void): QueryState<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthCloseWindowMessageParameters, TMeta, TSignal> | void), client?: (schema: GetAuthCloseWindowMessageSchema, options: {
            parameters: GetAuthCloseWindowMessageParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>): Promise<RequestFnResponse<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthCloseWindowMessageParameters | ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, updater: Updater<NoInfer<GetAuthCloseWindowMessageData> | undefined, NoInfer<GetAuthCloseWindowMessageData> | undefined>, options?: SetDataOptions): Array<GetAuthCloseWindowMessageData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthCloseWindowMessageParameters | undefined) | ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, updater: Updater<NoInfer<GetAuthCloseWindowMessageData> | undefined, NoInfer<GetAuthCloseWindowMessageData> | undefined>, options?: SetDataOptions): GetAuthCloseWindowMessageData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthCloseWindowMessageParameters | void): ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthCloseWindowMessage.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters, TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthCloseWindowMessageData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthCloseWindowMessage.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters, TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthCloseWindowMessageData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthCloseWindowMessageTotal = qraft.v1Service.getAuthCloseWindowMessage.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthCloseWindowMessageResults = qraft.v1Service.getAuthCloseWindowMessage.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthCloseWindowMessageResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthCloseWindowMessageCombinedResults = qraft.v1Service.getAuthCloseWindowMessage.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthCloseWindowMessageCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>, TCombinedResult = Array<UseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthCloseWindowMessageParameters | void): ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): UseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthCloseWindowMessage.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters, TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageData, ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthCloseWindowMessageData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        schema: GetAuthCloseWindowMessageSchema;
        types: {
            parameters: GetAuthCloseWindowMessageParameters;
            data: GetAuthCloseWindowMessageData;
            error: GetAuthCloseWindowMessageError;
        };
    };
    getAuthLogout: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthLogoutParameters | void): ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLogoutError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthLogoutParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, TPageParam, GetAuthLogoutError>): Promise<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthLogoutParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, TPageParam, GetAuthLogoutError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthLogoutParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, TPageParam, GetAuthLogoutError>): Promise<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, GetAuthLogoutError> | void): Promise<GetAuthLogoutData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, GetAuthLogoutError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, GetAuthLogoutError> | void): Promise<GetAuthLogoutData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void)): OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>,
            data: GetAuthLogoutData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void)): GetAuthLogoutData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void)): QueryState<GetAuthLogoutData, GetAuthLogoutError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthLogoutParameters | ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | void): QueryState<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>, GetAuthLogoutError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthLogoutParameters, TMeta, TSignal> | void), client?: (schema: GetAuthLogoutSchema, options: {
            parameters: GetAuthLogoutParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthLogoutData, GetAuthLogoutError>>): Promise<RequestFnResponse<GetAuthLogoutData, GetAuthLogoutError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthLogoutParameters | ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, updater: Updater<NoInfer<GetAuthLogoutData> | undefined, NoInfer<GetAuthLogoutData> | undefined>, options?: SetDataOptions): Array<GetAuthLogoutData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthLogoutParameters | undefined) | ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, updater: Updater<NoInfer<GetAuthLogoutData> | undefined, NoInfer<GetAuthLogoutData> | undefined>, options?: SetDataOptions): GetAuthLogoutData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthLogoutParameters | void): ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogout.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLogoutParameters, TData = GetAuthLogoutData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthLogoutData, GetAuthLogoutError, OperationInfiniteData<TData, GetAuthLogoutParameters>, ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLogoutData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogout.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLogoutParameters, TData = GetAuthLogoutData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthLogoutData, GetAuthLogoutError, OperationInfiniteData<TData, GetAuthLogoutParameters>, ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLogoutData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthLogoutTotal = qraft.v1Service.getAuthLogout.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthLogoutResults = qraft.v1Service.getAuthLogout.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLogoutResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthLogoutCombinedResults = qraft.v1Service.getAuthLogout.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLogoutCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthLogoutSchema, GetAuthLogoutParameters, GetAuthLogoutData, GetAuthLogoutError>>, TCombinedResult = Array<UseQueryResult<GetAuthLogoutData, GetAuthLogoutError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthLogoutData, GetAuthLogoutError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthLogoutParameters | void): ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogout.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthLogoutParameters, TData = GetAuthLogoutData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthLogoutData, GetAuthLogoutError, OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutData, ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLogoutData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthLogoutSchema, GetAuthLogoutParameters, GetAuthLogoutData, GetAuthLogoutError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthLogoutData, GetAuthLogoutError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthLogoutData, GetAuthLogoutError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthLogoutError | Error>;
        schema: GetAuthLogoutSchema;
        types: {
            parameters: GetAuthLogoutParameters;
            data: GetAuthLogoutData;
            error: GetAuthLogoutError;
        };
    };
    getAuthWhoami: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthWhoamiParameters | void): ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): UseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthWhoamiParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, TPageParam, GetAuthWhoamiError>): Promise<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthWhoamiParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, TPageParam, GetAuthWhoamiError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthWhoamiParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, TPageParam, GetAuthWhoamiError>): Promise<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, GetAuthWhoamiError> | void): Promise<GetAuthWhoamiData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, GetAuthWhoamiError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, GetAuthWhoamiError> | void): Promise<GetAuthWhoamiData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void)): OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>,
            data: GetAuthWhoamiData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void)): GetAuthWhoamiData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void)): QueryState<GetAuthWhoamiData, GetAuthWhoamiError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthWhoamiParameters | ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | void): QueryState<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>, GetAuthWhoamiError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthWhoamiParameters, TMeta, TSignal> | void), client?: (schema: GetAuthWhoamiSchema, options: {
            parameters: GetAuthWhoamiParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthWhoamiData, GetAuthWhoamiError>>): Promise<RequestFnResponse<GetAuthWhoamiData, GetAuthWhoamiError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthWhoamiParameters | ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, updater: Updater<NoInfer<GetAuthWhoamiData> | undefined, NoInfer<GetAuthWhoamiData> | undefined>, options?: SetDataOptions): Array<GetAuthWhoamiData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthWhoamiParameters | undefined) | ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, updater: Updater<NoInfer<GetAuthWhoamiData> | undefined, NoInfer<GetAuthWhoamiData> | undefined>, options?: SetDataOptions): GetAuthWhoamiData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthWhoamiParameters | void): ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthWhoami.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthWhoamiParameters, TData = GetAuthWhoamiData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthWhoamiData, GetAuthWhoamiError, OperationInfiniteData<TData, GetAuthWhoamiParameters>, ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthWhoamiData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthWhoami.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthWhoamiParameters, TData = GetAuthWhoamiData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthWhoamiData, GetAuthWhoamiError, OperationInfiniteData<TData, GetAuthWhoamiParameters>, ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthWhoamiData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthWhoamiTotal = qraft.v1Service.getAuthWhoami.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthWhoamiResults = qraft.v1Service.getAuthWhoami.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthWhoamiResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthWhoamiCombinedResults = qraft.v1Service.getAuthWhoami.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthWhoamiCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthWhoamiSchema, GetAuthWhoamiParameters, GetAuthWhoamiData, GetAuthWhoamiError>>, TCombinedResult = Array<UseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthWhoamiParameters | void): ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): UseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthWhoami.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthWhoamiParameters, TData = GetAuthWhoamiData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthWhoamiData, GetAuthWhoamiError, OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiData, ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthWhoamiData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthWhoamiSchema, GetAuthWhoamiParameters, GetAuthWhoamiData, GetAuthWhoamiError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthWhoamiError | Error>;
        schema: GetAuthWhoamiSchema;
        types: {
            parameters: GetAuthWhoamiParameters;
            data: GetAuthWhoamiData;
            error: GetAuthWhoamiError;
        };
    };
    getAuthMe: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthMeParameters | void): ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): UseQueryResult<TData, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthMeError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthMeParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, TPageParam, GetAuthMeError>): Promise<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthMeParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, TPageParam, GetAuthMeError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthMeParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, TPageParam, GetAuthMeError>): Promise<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, GetAuthMeError> | void): Promise<GetAuthMeData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, GetAuthMeError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, GetAuthMeError> | void): Promise<GetAuthMeData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void)): OperationInfiniteData<GetAuthMeData, GetAuthMeParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>,
            data: GetAuthMeData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void)): GetAuthMeData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void)): QueryState<GetAuthMeData, GetAuthMeError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthMeParameters | ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | void): QueryState<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>, GetAuthMeError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthMeSchema, GetAuthMeParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthMeParameters, TMeta, TSignal> | void), client?: (schema: GetAuthMeSchema, options: {
            parameters: GetAuthMeParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthMeData, GetAuthMeError>>): Promise<RequestFnResponse<GetAuthMeData, GetAuthMeError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthMeParameters | ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthMeData, GetAuthMeParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, updater: Updater<NoInfer<GetAuthMeData> | undefined, NoInfer<GetAuthMeData> | undefined>, options?: SetDataOptions): Array<GetAuthMeData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthMeParameters | undefined) | ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>, updater: Updater<NoInfer<GetAuthMeData> | undefined, NoInfer<GetAuthMeData> | undefined>, options?: SetDataOptions): GetAuthMeData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthMeParameters | void): ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthMe.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthMeParameters, TData = GetAuthMeData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthMeData, GetAuthMeError, OperationInfiniteData<TData, GetAuthMeParameters>, ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthMeData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthMe.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthMeParameters, TData = GetAuthMeData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthMeData, GetAuthMeError, OperationInfiniteData<TData, GetAuthMeParameters>, ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthMeData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthMeTotal = qraft.v1Service.getAuthMe.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthMeResults = qraft.v1Service.getAuthMe.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthMeResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthMeCombinedResults = qraft.v1Service.getAuthMe.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthMeCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthMeSchema, GetAuthMeParameters, GetAuthMeData, GetAuthMeError>>, TCombinedResult = Array<UseQueryResult<GetAuthMeData, GetAuthMeError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthMeData, GetAuthMeError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthMeParameters | void): ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): UseQueryResult<TData, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthMe.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthMeParameters, TData = GetAuthMeData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthMeData, GetAuthMeError, OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeData, ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthMeData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthMeSchema, GetAuthMeParameters, GetAuthMeData, GetAuthMeError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthMeData, GetAuthMeError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthMeData, GetAuthMeError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthMeError | Error>;
        schema: GetAuthMeSchema;
        types: {
            parameters: GetAuthMeParameters;
            data: GetAuthMeData;
            error: GetAuthMeError;
        };
    };
    postCliDockerPush: {
        /**/
        getMutationKey(parameters: PostCliDockerPushParameters | void): ServiceOperationMutationKey<PostCliDockerPushSchema, PostCliDockerPushParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation({
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostCliDockerPushBody, TContext = unknown>(parameters: PostCliDockerPushParameters, options?: ServiceOperationUseMutationOptions<PostCliDockerPushSchema, PostCliDockerPushData, PostCliDockerPushParameters, TVariables, PostCliDockerPushError, TContext>): UseMutationResult<PostCliDockerPushData, PostCliDockerPushError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation({
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliDockerPushBody, PostCliDockerPushParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliDockerPushSchema, PostCliDockerPushData, PostCliDockerPushParameters, TVariables, PostCliDockerPushError, TContext>): UseMutationResult<PostCliDockerPushData, PostCliDockerPushError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliDockerPushTotal = qraft.v1Service.postCliDockerPush.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliDockerPushTotal = qraft.v1Service.postCliDockerPush.useIsMutating({
         *     parameters: {
         *         header: {
         *             "x-api-key": xApiKey,
         *             "x-app-name": xAppName,
         *             "x-app-platform": xAppPlatform
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext> | MutationFiltersByMutationKey<PostCliDockerPushSchema, PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext> | MutationFiltersByMutationKey<PostCliDockerPushSchema, PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliDockerPushBody, PostCliDockerPushParameters>, client?: (schema: PostCliDockerPushSchema, options: ServiceOperationMutationFnOptions<PostCliDockerPushBody, PostCliDockerPushParameters>) => Promise<RequestFnResponse<PostCliDockerPushData, PostCliDockerPushError>>): Promise<RequestFnResponse<PostCliDockerPushData, PostCliDockerPushError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliDockerPushPendingMutationVariables = qraft.v1Service.postCliDockerPush.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliDockerPushMutationData = qraft.v1Service.postCliDockerPush.useMutationState({
         *     filters: {
         *         parameters: {
         *             header: {
         *                 "x-api-key": xApiKey,
         *                 "x-app-name": xAppName,
         *                 "x-app-platform": xAppPlatform
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliDockerPushData, PostCliDockerPushError, MutationVariables<PostCliDockerPushBody, PostCliDockerPushParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext> | MutationFiltersByMutationKey<PostCliDockerPushSchema, PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext>;
            select?: (mutation: Mutation<PostCliDockerPushData, PostCliDockerPushError, MutationVariables<PostCliDockerPushBody, PostCliDockerPushParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliDockerPushSchema;
        types: {
            parameters: PostCliDockerPushParameters;
            data: PostCliDockerPushData;
            error: PostCliDockerPushError;
            body: PostCliDockerPushBody;
        };
    };
    getCliRepos: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetCliReposParameters): ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options?: Omit<UndefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): UseQueryResult<TData, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<DefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliReposError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetCliReposParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, TPageParam, GetCliReposError>): Promise<OperationInfiniteData<GetCliReposData, GetCliReposParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetCliReposParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, TPageParam, GetCliReposError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetCliReposParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, TPageParam, GetCliReposError>): Promise<OperationInfiniteData<GetCliReposData, GetCliReposParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, GetCliReposError>): Promise<GetCliReposData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, GetCliReposError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, GetCliReposError>): Promise<GetCliReposData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters)): OperationInfiniteData<GetCliReposData, GetCliReposParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>,
            data: NoInfer<OperationInfiniteData<GetCliReposData, GetCliReposParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>,
            data: GetCliReposData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters)): GetCliReposData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters)): QueryState<GetCliReposData, GetCliReposError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetCliReposParameters | ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>): QueryState<OperationInfiniteData<GetCliReposData, GetCliReposParameters>, GetCliReposError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetCliReposSchema, GetCliReposParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetCliReposParameters, TMeta, TSignal>), client?: (schema: GetCliReposSchema, options: {
            parameters: GetCliReposParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetCliReposData, GetCliReposError>>): Promise<RequestFnResponse<GetCliReposData, GetCliReposError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetCliReposParameters | ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetCliReposData, GetCliReposParameters>> | undefined, NoInfer<OperationInfiniteData<GetCliReposData, GetCliReposParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetCliReposData, GetCliReposParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, updater: Updater<NoInfer<GetCliReposData> | undefined, NoInfer<GetCliReposData> | undefined>, options?: SetDataOptions): Array<GetCliReposData | undefined>;
        /**/
        setQueryData(parameters: (GetCliReposParameters) | ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>, updater: Updater<NoInfer<GetCliReposData> | undefined, NoInfer<GetCliReposData> | undefined>, options?: SetDataOptions): GetCliReposData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetCliReposParameters): ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliRepos.useInfiniteQuery({
         *     query: {
         *         type: type
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             type: initialType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliReposParameters, TData = GetCliReposData>(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetCliReposData, GetCliReposError, OperationInfiniteData<TData, GetCliReposParameters>, ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliReposData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliRepos.useInfiniteQuery({
         *     query: {
         *         type: type
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             type: initialType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliReposParameters, TData = GetCliReposData>(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetCliReposData, GetCliReposError, OperationInfiniteData<TData, GetCliReposParameters>, ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliReposData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getCliReposTotal = qraft.v1Service.getCliRepos.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getCliReposByParametersTotal = qraft.v1Service.getCliRepos.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             type: type
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getCliReposResults = qraft.v1Service.getCliRepos.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 type: type1
         *             }
         *         },
         *         {
         *             query: {
         *                 type: type2
         *             }
         *         }
         *     ]
         * });
         * getCliReposResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCliReposCombinedResults = qraft.v1Service.getCliRepos.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 type: type1
         *             }
         *         },
         *         {
         *             query: {
         *                 type: type2
         *             }
         *         }
         *     ]
         * });
         * getCliReposCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetCliReposSchema, GetCliReposParameters, GetCliReposData, GetCliReposError>>, TCombinedResult = Array<UseQueryResult<GetCliReposData, GetCliReposError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetCliReposData, GetCliReposError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetCliReposParameters): ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options?: Omit<UndefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): UseQueryResult<TData, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<DefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliRepos.useSuspenseInfiniteQuery({
         *     query: {
         *         type: type
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             type: initialType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetCliReposParameters, TData = GetCliReposData>(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetCliReposData, GetCliReposError, OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposData, ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliReposData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetCliReposSchema, GetCliReposParameters, GetCliReposData, GetCliReposError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetCliReposData, GetCliReposError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetCliReposData, GetCliReposError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options?: Omit<UseSuspenseQueryOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetCliReposError | Error>;
        schema: GetCliReposSchema;
        types: {
            parameters: GetCliReposParameters;
            data: GetCliReposData;
            error: GetCliReposError;
        };
    };
    postCliRepos: {
        /**/
        getMutationKey(parameters: PostCliReposParameters | void): ServiceOperationMutationKey<PostCliReposSchema, PostCliReposParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostCliReposBody, TContext = unknown>(parameters: PostCliReposParameters, options?: ServiceOperationUseMutationOptions<PostCliReposSchema, PostCliReposData, PostCliReposParameters, TVariables, PostCliReposError, TContext>): UseMutationResult<PostCliReposData, PostCliReposError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliReposBody, PostCliReposParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliReposSchema, PostCliReposData, PostCliReposParameters, TVariables, PostCliReposError, TContext>): UseMutationResult<PostCliReposData, PostCliReposError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliReposTotal = qraft.v1Service.postCliRepos.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliReposTotal = qraft.v1Service.postCliRepos.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext> | MutationFiltersByMutationKey<PostCliReposSchema, PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext> | MutationFiltersByMutationKey<PostCliReposSchema, PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliReposBody, PostCliReposParameters>, client?: (schema: PostCliReposSchema, options: ServiceOperationMutationFnOptions<PostCliReposBody, PostCliReposParameters>) => Promise<RequestFnResponse<PostCliReposData, PostCliReposError>>): Promise<RequestFnResponse<PostCliReposData, PostCliReposError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliReposPendingMutationVariables = qraft.v1Service.postCliRepos.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliReposMutationData = qraft.v1Service.postCliRepos.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliReposData, PostCliReposError, MutationVariables<PostCliReposBody, PostCliReposParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext> | MutationFiltersByMutationKey<PostCliReposSchema, PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext>;
            select?: (mutation: Mutation<PostCliReposData, PostCliReposError, MutationVariables<PostCliReposBody, PostCliReposParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliReposSchema;
        types: {
            parameters: PostCliReposParameters;
            data: PostCliReposData;
            error: PostCliReposError;
            body: PostCliReposBody;
        };
    };
    postCliProjectsProjectIdDeployments: {
        /**/
        getMutationKey(parameters: PostCliProjectsProjectIdDeploymentsParameters | void): ServiceOperationMutationKey<PostCliProjectsProjectIdDeploymentsSchema, PostCliProjectsProjectIdDeploymentsParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdDeployments.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdDeployments.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostCliProjectsProjectIdDeploymentsBody, TContext = unknown>(parameters: PostCliProjectsProjectIdDeploymentsParameters, options?: ServiceOperationUseMutationOptions<PostCliProjectsProjectIdDeploymentsSchema, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, TVariables, PostCliProjectsProjectIdDeploymentsError, TContext>): UseMutationResult<PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdDeployments.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdDeployments.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliProjectsProjectIdDeploymentsSchema, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, TVariables, PostCliProjectsProjectIdDeploymentsError, TContext>): UseMutationResult<PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliProjectsProjectIdDeploymentsTotal = qraft.v1Service.postCliProjectsProjectIdDeployments.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliProjectsProjectIdDeploymentsTotal = qraft.v1Service.postCliProjectsProjectIdDeployments.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, PostCliProjectsProjectIdDeploymentsError, TContext> | MutationFiltersByMutationKey<PostCliProjectsProjectIdDeploymentsSchema, PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, PostCliProjectsProjectIdDeploymentsError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, PostCliProjectsProjectIdDeploymentsError, TContext> | MutationFiltersByMutationKey<PostCliProjectsProjectIdDeploymentsSchema, PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, PostCliProjectsProjectIdDeploymentsError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsParameters>, client?: (schema: PostCliProjectsProjectIdDeploymentsSchema, options: ServiceOperationMutationFnOptions<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsParameters>) => Promise<RequestFnResponse<PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsError>>): Promise<RequestFnResponse<PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliProjectsProjectIdDeploymentsPendingMutationVariables = qraft.v1Service.postCliProjectsProjectIdDeployments.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliProjectsProjectIdDeploymentsMutationData = qraft.v1Service.postCliProjectsProjectIdDeployments.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsError, MutationVariables<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, PostCliProjectsProjectIdDeploymentsError, TContext> | MutationFiltersByMutationKey<PostCliProjectsProjectIdDeploymentsSchema, PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsParameters, PostCliProjectsProjectIdDeploymentsError, TContext>;
            select?: (mutation: Mutation<PostCliProjectsProjectIdDeploymentsData, PostCliProjectsProjectIdDeploymentsError, MutationVariables<PostCliProjectsProjectIdDeploymentsBody, PostCliProjectsProjectIdDeploymentsParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliProjectsProjectIdDeploymentsSchema;
        types: {
            parameters: PostCliProjectsProjectIdDeploymentsParameters;
            data: PostCliProjectsProjectIdDeploymentsData;
            error: PostCliProjectsProjectIdDeploymentsError;
            body: PostCliProjectsProjectIdDeploymentsBody;
        };
    };
    postCliProjects: {
        /**/
        getMutationKey(parameters: PostCliProjectsParameters | void): ServiceOperationMutationKey<PostCliProjectsSchema, PostCliProjectsParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjects.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjects.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostCliProjectsBody, TContext = unknown>(parameters: PostCliProjectsParameters, options?: ServiceOperationUseMutationOptions<PostCliProjectsSchema, PostCliProjectsData, PostCliProjectsParameters, TVariables, PostCliProjectsError, TContext>): UseMutationResult<PostCliProjectsData, PostCliProjectsError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjects.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjects.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliProjectsBody, PostCliProjectsParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliProjectsSchema, PostCliProjectsData, PostCliProjectsParameters, TVariables, PostCliProjectsError, TContext>): UseMutationResult<PostCliProjectsData, PostCliProjectsError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliProjectsTotal = qraft.v1Service.postCliProjects.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliProjectsTotal = qraft.v1Service.postCliProjects.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliProjectsBody, PostCliProjectsData, PostCliProjectsParameters, PostCliProjectsError, TContext> | MutationFiltersByMutationKey<PostCliProjectsSchema, PostCliProjectsBody, PostCliProjectsData, PostCliProjectsParameters, PostCliProjectsError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliProjectsBody, PostCliProjectsData, PostCliProjectsParameters, PostCliProjectsError, TContext> | MutationFiltersByMutationKey<PostCliProjectsSchema, PostCliProjectsBody, PostCliProjectsData, PostCliProjectsParameters, PostCliProjectsError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliProjectsBody, PostCliProjectsParameters>, client?: (schema: PostCliProjectsSchema, options: ServiceOperationMutationFnOptions<PostCliProjectsBody, PostCliProjectsParameters>) => Promise<RequestFnResponse<PostCliProjectsData, PostCliProjectsError>>): Promise<RequestFnResponse<PostCliProjectsData, PostCliProjectsError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliProjectsPendingMutationVariables = qraft.v1Service.postCliProjects.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliProjectsMutationData = qraft.v1Service.postCliProjects.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliProjectsData, PostCliProjectsError, MutationVariables<PostCliProjectsBody, PostCliProjectsParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliProjectsBody, PostCliProjectsData, PostCliProjectsParameters, PostCliProjectsError, TContext> | MutationFiltersByMutationKey<PostCliProjectsSchema, PostCliProjectsBody, PostCliProjectsData, PostCliProjectsParameters, PostCliProjectsError, TContext>;
            select?: (mutation: Mutation<PostCliProjectsData, PostCliProjectsError, MutationVariables<PostCliProjectsBody, PostCliProjectsParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliProjectsSchema;
        types: {
            parameters: PostCliProjectsParameters;
            data: PostCliProjectsData;
            error: PostCliProjectsError;
            body: PostCliProjectsBody;
        };
    };
    getCliProjectsProjectId: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetCliProjectsProjectIdParameters): ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options?: Omit<UndefinedInitialDataOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, TData, ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>>, "queryKey">): UseQueryResult<TData, GetCliProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options: Omit<DefinedInitialDataOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, TData, ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliProjectsProjectIdError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetCliProjectsProjectIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters, TPageParam, GetCliProjectsProjectIdError>): Promise<OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetCliProjectsProjectIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters, TPageParam, GetCliProjectsProjectIdError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetCliProjectsProjectIdParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters, TPageParam, GetCliProjectsProjectIdError>): Promise<OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): Promise<GetCliProjectsProjectIdData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): Promise<GetCliProjectsProjectIdData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters)): OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>,
            data: NoInfer<OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>,
            data: GetCliProjectsProjectIdData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters)): GetCliProjectsProjectIdData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters)): QueryState<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetCliProjectsProjectIdParameters | ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>): QueryState<OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters>, GetCliProjectsProjectIdError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetCliProjectsProjectIdParameters, TMeta, TSignal>), client?: (schema: GetCliProjectsProjectIdSchema, options: {
            parameters: GetCliProjectsProjectIdParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>): Promise<RequestFnResponse<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetCliProjectsProjectIdParameters | ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters>> | undefined, NoInfer<OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetCliProjectsProjectIdData, GetCliProjectsProjectIdParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>, updater: Updater<NoInfer<GetCliProjectsProjectIdData> | undefined, NoInfer<GetCliProjectsProjectIdData> | undefined>, options?: SetDataOptions): Array<GetCliProjectsProjectIdData | undefined>;
        /**/
        setQueryData(parameters: (GetCliProjectsProjectIdParameters) | ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>, updater: Updater<NoInfer<GetCliProjectsProjectIdData> | undefined, NoInfer<GetCliProjectsProjectIdData> | undefined>, options?: SetDataOptions): GetCliProjectsProjectIdData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetCliProjectsProjectIdParameters): ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliProjectsProjectId.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliProjectsProjectIdParameters, TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, OperationInfiniteData<TData, GetCliProjectsProjectIdParameters>, ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliProjectsProjectIdData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetCliProjectsProjectIdParameters>, GetCliProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliProjectsProjectId.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliProjectsProjectIdParameters, TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, OperationInfiniteData<TData, GetCliProjectsProjectIdParameters>, ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliProjectsProjectIdData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetCliProjectsProjectIdParameters>, GetCliProjectsProjectIdError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getCliProjectsProjectIdTotal = qraft.v1Service.getCliProjectsProjectId.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getCliProjectsProjectIdByParametersTotal = qraft.v1Service.getCliProjectsProjectId.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError> | QueryFiltersByQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdData, TInfinite, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getCliProjectsProjectIdResults = qraft.v1Service.getCliProjectsProjectId.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getCliProjectsProjectIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCliProjectsProjectIdCombinedResults = qraft.v1Service.getCliProjectsProjectId.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getCliProjectsProjectIdCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>, TCombinedResult = Array<UseQueryResult<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetCliProjectsProjectIdParameters): ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options?: Omit<UndefinedInitialDataOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, TData, ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>>, "queryKey">): UseQueryResult<TData, GetCliProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options: Omit<DefinedInitialDataOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, TData, ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliProjectsProjectId.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetCliProjectsProjectIdParameters, TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, OperationInfiniteData<TData, GetCliProjectsProjectIdParameters>, GetCliProjectsProjectIdData, ServiceOperationInfiniteQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliProjectsProjectIdData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetCliProjectsProjectIdParameters>, GetCliProjectsProjectIdError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters, GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetCliProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters> | (GetCliProjectsProjectIdParameters), options?: Omit<UseSuspenseQueryOptions<GetCliProjectsProjectIdData, GetCliProjectsProjectIdError, TData, ServiceOperationQueryKey<GetCliProjectsProjectIdSchema, GetCliProjectsProjectIdParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetCliProjectsProjectIdError | Error>;
        schema: GetCliProjectsProjectIdSchema;
        types: {
            parameters: GetCliProjectsProjectIdParameters;
            data: GetCliProjectsProjectIdData;
            error: GetCliProjectsProjectIdError;
        };
    };
    postCliProjectsGetProjectByRepoUrl: {
        /**/
        getMutationKey(parameters: PostCliProjectsGetProjectByRepoUrlParameters | void): ServiceOperationMutationKey<PostCliProjectsGetProjectByRepoUrlSchema, PostCliProjectsGetProjectByRepoUrlParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostCliProjectsGetProjectByRepoUrlBody, TContext = unknown>(parameters: PostCliProjectsGetProjectByRepoUrlParameters, options?: ServiceOperationUseMutationOptions<PostCliProjectsGetProjectByRepoUrlSchema, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, TVariables, PostCliProjectsGetProjectByRepoUrlError, TContext>): UseMutationResult<PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliProjectsGetProjectByRepoUrlSchema, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, TVariables, PostCliProjectsGetProjectByRepoUrlError, TContext>): UseMutationResult<PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliProjectsGetProjectByRepoUrlTotal = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliProjectsGetProjectByRepoUrlTotal = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, PostCliProjectsGetProjectByRepoUrlError, TContext> | MutationFiltersByMutationKey<PostCliProjectsGetProjectByRepoUrlSchema, PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, PostCliProjectsGetProjectByRepoUrlError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, PostCliProjectsGetProjectByRepoUrlError, TContext> | MutationFiltersByMutationKey<PostCliProjectsGetProjectByRepoUrlSchema, PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, PostCliProjectsGetProjectByRepoUrlError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlParameters>, client?: (schema: PostCliProjectsGetProjectByRepoUrlSchema, options: ServiceOperationMutationFnOptions<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlParameters>) => Promise<RequestFnResponse<PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlError>>): Promise<RequestFnResponse<PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliProjectsGetProjectByRepoUrlPendingMutationVariables = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliProjectsGetProjectByRepoUrlMutationData = qraft.v1Service.postCliProjectsGetProjectByRepoUrl.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlError, MutationVariables<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, PostCliProjectsGetProjectByRepoUrlError, TContext> | MutationFiltersByMutationKey<PostCliProjectsGetProjectByRepoUrlSchema, PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlParameters, PostCliProjectsGetProjectByRepoUrlError, TContext>;
            select?: (mutation: Mutation<PostCliProjectsGetProjectByRepoUrlData, PostCliProjectsGetProjectByRepoUrlError, MutationVariables<PostCliProjectsGetProjectByRepoUrlBody, PostCliProjectsGetProjectByRepoUrlParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliProjectsGetProjectByRepoUrlSchema;
        types: {
            parameters: PostCliProjectsGetProjectByRepoUrlParameters;
            data: PostCliProjectsGetProjectByRepoUrlData;
            error: PostCliProjectsGetProjectByRepoUrlError;
            body: PostCliProjectsGetProjectByRepoUrlBody;
        };
    };
    postCliProjectsProjectIdRestore: {
        /**/
        getMutationKey(parameters: PostCliProjectsProjectIdRestoreParameters | void): ServiceOperationMutationKey<PostCliProjectsProjectIdRestoreSchema, PostCliProjectsProjectIdRestoreParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdRestore.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdRestore.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostCliProjectsProjectIdRestoreBody, TContext = unknown>(parameters: PostCliProjectsProjectIdRestoreParameters, options?: ServiceOperationUseMutationOptions<PostCliProjectsProjectIdRestoreSchema, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, TVariables, PostCliProjectsProjectIdRestoreError, TContext>): UseMutationResult<PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdRestore.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliProjectsProjectIdRestore.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliProjectsProjectIdRestoreSchema, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, TVariables, PostCliProjectsProjectIdRestoreError, TContext>): UseMutationResult<PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliProjectsProjectIdRestoreTotal = qraft.v1Service.postCliProjectsProjectIdRestore.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliProjectsProjectIdRestoreTotal = qraft.v1Service.postCliProjectsProjectIdRestore.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, PostCliProjectsProjectIdRestoreError, TContext> | MutationFiltersByMutationKey<PostCliProjectsProjectIdRestoreSchema, PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, PostCliProjectsProjectIdRestoreError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, PostCliProjectsProjectIdRestoreError, TContext> | MutationFiltersByMutationKey<PostCliProjectsProjectIdRestoreSchema, PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, PostCliProjectsProjectIdRestoreError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreParameters>, client?: (schema: PostCliProjectsProjectIdRestoreSchema, options: ServiceOperationMutationFnOptions<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreParameters>) => Promise<RequestFnResponse<PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreError>>): Promise<RequestFnResponse<PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliProjectsProjectIdRestorePendingMutationVariables = qraft.v1Service.postCliProjectsProjectIdRestore.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliProjectsProjectIdRestoreMutationData = qraft.v1Service.postCliProjectsProjectIdRestore.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreError, MutationVariables<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, PostCliProjectsProjectIdRestoreError, TContext> | MutationFiltersByMutationKey<PostCliProjectsProjectIdRestoreSchema, PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreParameters, PostCliProjectsProjectIdRestoreError, TContext>;
            select?: (mutation: Mutation<PostCliProjectsProjectIdRestoreData, PostCliProjectsProjectIdRestoreError, MutationVariables<PostCliProjectsProjectIdRestoreBody, PostCliProjectsProjectIdRestoreParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliProjectsProjectIdRestoreSchema;
        types: {
            parameters: PostCliProjectsProjectIdRestoreParameters;
            data: PostCliProjectsProjectIdRestoreData;
            error: PostCliProjectsProjectIdRestoreError;
            body: PostCliProjectsProjectIdRestoreBody;
        };
    };
    getCliLocations: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetCliLocationsParameters | void): ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliLocations.useQuery()
         * ```
         */
        useQuery<TData = GetCliLocationsData>(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetCliLocationsData, GetCliLocationsError, TData, ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>>, "queryKey">): UseQueryResult<TData, GetCliLocationsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliLocations.useQuery()
         * ```
         */
        useQuery<TData = GetCliLocationsData>(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options: Omit<DefinedInitialDataOptions<GetCliLocationsData, GetCliLocationsError, TData, ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliLocationsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetCliLocationsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliLocationsSchema, GetCliLocationsData, GetCliLocationsParameters, TPageParam, GetCliLocationsError>): Promise<OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetCliLocationsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliLocationsSchema, GetCliLocationsData, GetCliLocationsParameters, TPageParam, GetCliLocationsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetCliLocationsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetCliLocationsSchema, GetCliLocationsData, GetCliLocationsParameters, TPageParam, GetCliLocationsError>): Promise<OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetCliLocationsSchema, GetCliLocationsData, GetCliLocationsParameters, GetCliLocationsError> | void): Promise<GetCliLocationsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetCliLocationsSchema, GetCliLocationsData, GetCliLocationsParameters, GetCliLocationsError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetCliLocationsSchema, GetCliLocationsData, GetCliLocationsParameters, GetCliLocationsError> | void): Promise<GetCliLocationsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void)): OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>,
            data: NoInfer<OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>,
            data: GetCliLocationsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void)): GetCliLocationsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void)): QueryState<GetCliLocationsData, GetCliLocationsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetCliLocationsParameters | ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | void): QueryState<OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters>, GetCliLocationsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetCliLocationsSchema, GetCliLocationsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetCliLocationsParameters, TMeta, TSignal> | void), client?: (schema: GetCliLocationsSchema, options: {
            parameters: GetCliLocationsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetCliLocationsData, GetCliLocationsError>>): Promise<RequestFnResponse<GetCliLocationsData, GetCliLocationsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetCliLocationsParameters | ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters>> | undefined, NoInfer<OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetCliLocationsData, GetCliLocationsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>, updater: Updater<NoInfer<GetCliLocationsData> | undefined, NoInfer<GetCliLocationsData> | undefined>, options?: SetDataOptions): Array<GetCliLocationsData | undefined>;
        /**/
        setQueryData(parameters: (GetCliLocationsParameters | undefined) | ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>, updater: Updater<NoInfer<GetCliLocationsData> | undefined, NoInfer<GetCliLocationsData> | undefined>, options?: SetDataOptions): GetCliLocationsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetCliLocationsParameters | void): ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliLocations.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliLocationsParameters, TData = GetCliLocationsData>(parameters: ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetCliLocationsData, GetCliLocationsError, OperationInfiniteData<TData, GetCliLocationsParameters>, ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliLocationsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetCliLocationsParameters>, GetCliLocationsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliLocations.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliLocationsParameters, TData = GetCliLocationsData>(parameters: ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetCliLocationsData, GetCliLocationsError, OperationInfiniteData<TData, GetCliLocationsParameters>, ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliLocationsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetCliLocationsParameters>, GetCliLocationsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getCliLocationsTotal = qraft.v1Service.getCliLocations.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError> | QueryFiltersByQueryKey<GetCliLocationsSchema, GetCliLocationsData, TInfinite, GetCliLocationsParameters, GetCliLocationsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getCliLocationsResults = qraft.v1Service.getCliLocations.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getCliLocationsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCliLocationsCombinedResults = qraft.v1Service.getCliLocations.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getCliLocationsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetCliLocationsSchema, GetCliLocationsParameters, GetCliLocationsData, GetCliLocationsError>>, TCombinedResult = Array<UseQueryResult<GetCliLocationsData, GetCliLocationsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetCliLocationsData, GetCliLocationsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetCliLocationsParameters | void): ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliLocations.useQuery()
         * ```
         */
        useQuery<TData = GetCliLocationsData>(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetCliLocationsData, GetCliLocationsError, TData, ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>>, "queryKey">): UseQueryResult<TData, GetCliLocationsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliLocations.useQuery()
         * ```
         */
        useQuery<TData = GetCliLocationsData>(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options: Omit<DefinedInitialDataOptions<GetCliLocationsData, GetCliLocationsError, TData, ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliLocationsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliLocations.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetCliLocationsParameters, TData = GetCliLocationsData>(parameters: ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetCliLocationsData, GetCliLocationsError, OperationInfiniteData<TData, GetCliLocationsParameters>, GetCliLocationsData, ServiceOperationInfiniteQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliLocationsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetCliLocationsParameters>, GetCliLocationsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetCliLocationsSchema, GetCliLocationsParameters, GetCliLocationsData, GetCliLocationsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetCliLocationsData, GetCliLocationsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetCliLocationsData, GetCliLocationsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetCliLocationsData>(parameters: ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters> | (GetCliLocationsParameters | void), options?: Omit<UseSuspenseQueryOptions<GetCliLocationsData, GetCliLocationsError, TData, ServiceOperationQueryKey<GetCliLocationsSchema, GetCliLocationsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetCliLocationsError | Error>;
        schema: GetCliLocationsSchema;
        types: {
            parameters: GetCliLocationsParameters;
            data: GetCliLocationsData;
            error: GetCliLocationsError;
        };
    };
    postCliModulesAdd: {
        /**/
        getMutationKey(parameters: PostCliModulesAddParameters | void): ServiceOperationMutationKey<PostCliModulesAddSchema, PostCliModulesAddParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesAdd.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesAdd.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostCliModulesAddBody, TContext = unknown>(parameters: PostCliModulesAddParameters, options?: ServiceOperationUseMutationOptions<PostCliModulesAddSchema, PostCliModulesAddData, PostCliModulesAddParameters, TVariables, PostCliModulesAddError, TContext>): UseMutationResult<PostCliModulesAddData, PostCliModulesAddError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesAdd.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesAdd.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliModulesAddBody, PostCliModulesAddParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliModulesAddSchema, PostCliModulesAddData, PostCliModulesAddParameters, TVariables, PostCliModulesAddError, TContext>): UseMutationResult<PostCliModulesAddData, PostCliModulesAddError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliModulesAddTotal = qraft.v1Service.postCliModulesAdd.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliModulesAddTotal = qraft.v1Service.postCliModulesAdd.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliModulesAddBody, PostCliModulesAddData, PostCliModulesAddParameters, PostCliModulesAddError, TContext> | MutationFiltersByMutationKey<PostCliModulesAddSchema, PostCliModulesAddBody, PostCliModulesAddData, PostCliModulesAddParameters, PostCliModulesAddError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliModulesAddBody, PostCliModulesAddData, PostCliModulesAddParameters, PostCliModulesAddError, TContext> | MutationFiltersByMutationKey<PostCliModulesAddSchema, PostCliModulesAddBody, PostCliModulesAddData, PostCliModulesAddParameters, PostCliModulesAddError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliModulesAddBody, PostCliModulesAddParameters>, client?: (schema: PostCliModulesAddSchema, options: ServiceOperationMutationFnOptions<PostCliModulesAddBody, PostCliModulesAddParameters>) => Promise<RequestFnResponse<PostCliModulesAddData, PostCliModulesAddError>>): Promise<RequestFnResponse<PostCliModulesAddData, PostCliModulesAddError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliModulesAddPendingMutationVariables = qraft.v1Service.postCliModulesAdd.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliModulesAddMutationData = qraft.v1Service.postCliModulesAdd.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliModulesAddData, PostCliModulesAddError, MutationVariables<PostCliModulesAddBody, PostCliModulesAddParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliModulesAddBody, PostCliModulesAddData, PostCliModulesAddParameters, PostCliModulesAddError, TContext> | MutationFiltersByMutationKey<PostCliModulesAddSchema, PostCliModulesAddBody, PostCliModulesAddData, PostCliModulesAddParameters, PostCliModulesAddError, TContext>;
            select?: (mutation: Mutation<PostCliModulesAddData, PostCliModulesAddError, MutationVariables<PostCliModulesAddBody, PostCliModulesAddParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliModulesAddSchema;
        types: {
            parameters: PostCliModulesAddParameters;
            data: PostCliModulesAddData;
            error: PostCliModulesAddError;
            body: PostCliModulesAddBody;
        };
    };
    postCliModulesForkModules: {
        /**/
        getMutationKey(parameters: PostCliModulesForkModulesParameters | void): ServiceOperationMutationKey<PostCliModulesForkModulesSchema, PostCliModulesForkModulesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesForkModules.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesForkModules.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostCliModulesForkModulesBody, TContext = unknown>(parameters: PostCliModulesForkModulesParameters, options?: ServiceOperationUseMutationOptions<PostCliModulesForkModulesSchema, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, TVariables, PostCliModulesForkModulesError, TContext>): UseMutationResult<PostCliModulesForkModulesData, PostCliModulesForkModulesError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesForkModules.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliModulesForkModules.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliModulesForkModulesBody, PostCliModulesForkModulesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliModulesForkModulesSchema, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, TVariables, PostCliModulesForkModulesError, TContext>): UseMutationResult<PostCliModulesForkModulesData, PostCliModulesForkModulesError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliModulesForkModulesTotal = qraft.v1Service.postCliModulesForkModules.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliModulesForkModulesTotal = qraft.v1Service.postCliModulesForkModules.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliModulesForkModulesBody, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, PostCliModulesForkModulesError, TContext> | MutationFiltersByMutationKey<PostCliModulesForkModulesSchema, PostCliModulesForkModulesBody, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, PostCliModulesForkModulesError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliModulesForkModulesBody, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, PostCliModulesForkModulesError, TContext> | MutationFiltersByMutationKey<PostCliModulesForkModulesSchema, PostCliModulesForkModulesBody, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, PostCliModulesForkModulesError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliModulesForkModulesBody, PostCliModulesForkModulesParameters>, client?: (schema: PostCliModulesForkModulesSchema, options: ServiceOperationMutationFnOptions<PostCliModulesForkModulesBody, PostCliModulesForkModulesParameters>) => Promise<RequestFnResponse<PostCliModulesForkModulesData, PostCliModulesForkModulesError>>): Promise<RequestFnResponse<PostCliModulesForkModulesData, PostCliModulesForkModulesError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliModulesForkModulesPendingMutationVariables = qraft.v1Service.postCliModulesForkModules.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliModulesForkModulesMutationData = qraft.v1Service.postCliModulesForkModules.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliModulesForkModulesData, PostCliModulesForkModulesError, MutationVariables<PostCliModulesForkModulesBody, PostCliModulesForkModulesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliModulesForkModulesBody, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, PostCliModulesForkModulesError, TContext> | MutationFiltersByMutationKey<PostCliModulesForkModulesSchema, PostCliModulesForkModulesBody, PostCliModulesForkModulesData, PostCliModulesForkModulesParameters, PostCliModulesForkModulesError, TContext>;
            select?: (mutation: Mutation<PostCliModulesForkModulesData, PostCliModulesForkModulesError, MutationVariables<PostCliModulesForkModulesBody, PostCliModulesForkModulesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliModulesForkModulesSchema;
        types: {
            parameters: PostCliModulesForkModulesParameters;
            data: PostCliModulesForkModulesData;
            error: PostCliModulesForkModulesError;
            body: PostCliModulesForkModulesBody;
        };
    };
    getExample: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetExampleParameters): ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options?: Omit<UndefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): UseQueryResult<TData, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<DefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetExampleError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetExampleParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, TPageParam, GetExampleError>): Promise<OperationInfiniteData<GetExampleData, GetExampleParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetExampleParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, TPageParam, GetExampleError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetExampleParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetExampleSchema, GetExampleData, GetExampleParameters, TPageParam, GetExampleError>): Promise<OperationInfiniteData<GetExampleData, GetExampleParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, GetExampleError>): Promise<GetExampleData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, GetExampleError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetExampleSchema, GetExampleData, GetExampleParameters, GetExampleError>): Promise<GetExampleData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters)): OperationInfiniteData<GetExampleData, GetExampleParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>,
            data: NoInfer<OperationInfiniteData<GetExampleData, GetExampleParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>,
            data: GetExampleData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters)): GetExampleData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters)): QueryState<GetExampleData, GetExampleError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetExampleParameters | ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>): QueryState<OperationInfiniteData<GetExampleData, GetExampleParameters>, GetExampleError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetExampleSchema, GetExampleParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetExampleParameters, TMeta, TSignal>), client?: (schema: GetExampleSchema, options: {
            parameters: GetExampleParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetExampleData, GetExampleError>>): Promise<RequestFnResponse<GetExampleData, GetExampleError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetExampleParameters | ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetExampleData, GetExampleParameters>> | undefined, NoInfer<OperationInfiniteData<GetExampleData, GetExampleParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetExampleData, GetExampleParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, updater: Updater<NoInfer<GetExampleData> | undefined, NoInfer<GetExampleData> | undefined>, options?: SetDataOptions): Array<GetExampleData | undefined>;
        /**/
        setQueryData(parameters: (GetExampleParameters) | ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>, updater: Updater<NoInfer<GetExampleData> | undefined, NoInfer<GetExampleData> | undefined>, options?: SetDataOptions): GetExampleData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetExampleParameters): ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getExample.useInfiniteQuery({
         *     query: {
         *         name: name
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             name: initialName
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetExampleParameters, TData = GetExampleData>(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetExampleData, GetExampleError, OperationInfiniteData<TData, GetExampleParameters>, ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetExampleData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetExampleParameters>, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getExample.useInfiniteQuery({
         *     query: {
         *         name: name
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             name: initialName
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetExampleParameters, TData = GetExampleData>(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetExampleData, GetExampleError, OperationInfiniteData<TData, GetExampleParameters>, ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetExampleData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetExampleParameters>, GetExampleError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getExampleTotal = qraft.v1Service.getExample.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getExampleByParametersTotal = qraft.v1Service.getExample.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             name: name
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getExampleResults = qraft.v1Service.getExample.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 name: name1
         *             }
         *         },
         *         {
         *             query: {
         *                 name: name2
         *             }
         *         }
         *     ]
         * });
         * getExampleResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getExampleCombinedResults = qraft.v1Service.getExample.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 name: name1
         *             }
         *         },
         *         {
         *             query: {
         *                 name: name2
         *             }
         *         }
         *     ]
         * });
         * getExampleCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetExampleSchema, GetExampleParameters, GetExampleData, GetExampleError>>, TCombinedResult = Array<UseQueryResult<GetExampleData, GetExampleError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetExampleData, GetExampleError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetExampleParameters): ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options?: Omit<UndefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): UseQueryResult<TData, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<DefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getExample.useSuspenseInfiniteQuery({
         *     query: {
         *         name: name
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             name: initialName
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetExampleParameters, TData = GetExampleData>(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetExampleData, GetExampleError, OperationInfiniteData<TData, GetExampleParameters>, GetExampleData, ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetExampleData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetExampleParameters>, GetExampleError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetExampleSchema, GetExampleParameters, GetExampleData, GetExampleError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetExampleData, GetExampleError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetExampleData, GetExampleError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options?: Omit<UseSuspenseQueryOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetExampleError | Error>;
        schema: GetExampleSchema;
        types: {
            parameters: GetExampleParameters;
            data: GetExampleData;
            error: GetExampleError;
        };
    };
    getGithubGetInstallAppUrl: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetGithubGetInstallAppUrlParameters | void): ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, TPageParam, GetGithubGetInstallAppUrlError>): Promise<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, TPageParam, GetGithubGetInstallAppUrlError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetGithubGetInstallAppUrlParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, TPageParam, GetGithubGetInstallAppUrlError>): Promise<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | void): Promise<GetGithubGetInstallAppUrlData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | void): Promise<GetGithubGetInstallAppUrlData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void)): OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>,
            data: NoInfer<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>,
            data: GetGithubGetInstallAppUrlData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void)): GetGithubGetInstallAppUrlData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void)): QueryState<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetGithubGetInstallAppUrlParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | void): QueryState<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGithubGetInstallAppUrlParameters, TMeta, TSignal> | void), client?: (schema: GetGithubGetInstallAppUrlSchema, options: {
            parameters: GetGithubGetInstallAppUrlParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>): Promise<RequestFnResponse<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetGithubGetInstallAppUrlParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>> | undefined, NoInfer<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, updater: Updater<NoInfer<GetGithubGetInstallAppUrlData> | undefined, NoInfer<GetGithubGetInstallAppUrlData> | undefined>, options?: SetDataOptions): Array<GetGithubGetInstallAppUrlData | undefined>;
        /**/
        setQueryData(parameters: (GetGithubGetInstallAppUrlParameters | undefined) | ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, updater: Updater<NoInfer<GetGithubGetInstallAppUrlData> | undefined, NoInfer<GetGithubGetInstallAppUrlData> | undefined>, options?: SetDataOptions): GetGithubGetInstallAppUrlData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetGithubGetInstallAppUrlParameters | void): ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstallAppUrl.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters, TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstallAppUrlData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstallAppUrl.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters, TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstallAppUrlData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getGithubGetInstallAppUrlTotal = qraft.v1Service.getGithubGetInstallAppUrl.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getGithubGetInstallAppUrlResults = qraft.v1Service.getGithubGetInstallAppUrl.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstallAppUrlResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getGithubGetInstallAppUrlCombinedResults = qraft.v1Service.getGithubGetInstallAppUrl.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstallAppUrlCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>, TCombinedResult = Array<UseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetGithubGetInstallAppUrlParameters | void): ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstallAppUrl.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters, TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlData, ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstallAppUrlData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options?: Omit<UseSuspenseQueryOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        schema: GetGithubGetInstallAppUrlSchema;
        types: {
            parameters: GetGithubGetInstallAppUrlParameters;
            data: GetGithubGetInstallAppUrlData;
            error: GetGithubGetInstallAppUrlError;
        };
    };
    getGithubGetInstalledOrganizations: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetGithubGetInstalledOrganizationsParameters | void): ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, TPageParam, GetGithubGetInstalledOrganizationsError>): Promise<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, TPageParam, GetGithubGetInstalledOrganizationsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetGithubGetInstalledOrganizationsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, TPageParam, GetGithubGetInstalledOrganizationsError>): Promise<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | void): Promise<GetGithubGetInstalledOrganizationsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | void): Promise<GetGithubGetInstalledOrganizationsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void)): OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>,
            data: NoInfer<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>,
            data: GetGithubGetInstalledOrganizationsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void)): GetGithubGetInstalledOrganizationsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void)): QueryState<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetGithubGetInstalledOrganizationsParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | void): QueryState<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGithubGetInstalledOrganizationsParameters, TMeta, TSignal> | void), client?: (schema: GetGithubGetInstalledOrganizationsSchema, options: {
            parameters: GetGithubGetInstalledOrganizationsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>): Promise<RequestFnResponse<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetGithubGetInstalledOrganizationsParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>> | undefined, NoInfer<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, updater: Updater<NoInfer<GetGithubGetInstalledOrganizationsData> | undefined, NoInfer<GetGithubGetInstalledOrganizationsData> | undefined>, options?: SetDataOptions): Array<GetGithubGetInstalledOrganizationsData | undefined>;
        /**/
        setQueryData(parameters: (GetGithubGetInstalledOrganizationsParameters | undefined) | ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, updater: Updater<NoInfer<GetGithubGetInstalledOrganizationsData> | undefined, NoInfer<GetGithubGetInstalledOrganizationsData> | undefined>, options?: SetDataOptions): GetGithubGetInstalledOrganizationsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetGithubGetInstalledOrganizationsParameters | void): ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstalledOrganizations.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters, TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstalledOrganizationsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstalledOrganizations.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters, TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstalledOrganizationsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getGithubGetInstalledOrganizationsTotal = qraft.v1Service.getGithubGetInstalledOrganizations.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getGithubGetInstalledOrganizationsResults = qraft.v1Service.getGithubGetInstalledOrganizations.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstalledOrganizationsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getGithubGetInstalledOrganizationsCombinedResults = qraft.v1Service.getGithubGetInstalledOrganizations.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstalledOrganizationsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>, TCombinedResult = Array<UseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetGithubGetInstalledOrganizationsParameters | void): ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstalledOrganizations.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters, TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsData, ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstalledOrganizationsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options?: Omit<UseSuspenseQueryOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        schema: GetGithubGetInstalledOrganizationsSchema;
        types: {
            parameters: GetGithubGetInstalledOrganizationsParameters;
            data: GetGithubGetInstalledOrganizationsData;
            error: GetGithubGetInstalledOrganizationsError;
        };
    };
    postGithubSetDeafultOrganization: {
        /**/
        getMutationKey(parameters: PostGithubSetDeafultOrganizationParameters | void): ServiceOperationMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostGithubSetDeafultOrganizationBody, TContext = unknown>(parameters: PostGithubSetDeafultOrganizationParameters, options?: ServiceOperationUseMutationOptions<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, TVariables, PostGithubSetDeafultOrganizationError, TContext>): UseMutationResult<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, TVariables, PostGithubSetDeafultOrganizationError, TContext>): UseMutationResult<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postGithubSetDeafultOrganizationTotal = qraft.v1Service.postGithubSetDeafultOrganization.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postGithubSetDeafultOrganizationTotal = qraft.v1Service.postGithubSetDeafultOrganization.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext> | MutationFiltersByMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext> | MutationFiltersByMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, client?: (schema: PostGithubSetDeafultOrganizationSchema, options: ServiceOperationMutationFnOptions<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>) => Promise<RequestFnResponse<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError>>): Promise<RequestFnResponse<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postGithubSetDeafultOrganizationPendingMutationVariables = qraft.v1Service.postGithubSetDeafultOrganization.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postGithubSetDeafultOrganizationMutationData = qraft.v1Service.postGithubSetDeafultOrganization.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError, MutationVariables<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext> | MutationFiltersByMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext>;
            select?: (mutation: Mutation<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError, MutationVariables<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostGithubSetDeafultOrganizationSchema;
        types: {
            parameters: PostGithubSetDeafultOrganizationParameters;
            data: PostGithubSetDeafultOrganizationData;
            error: PostGithubSetDeafultOrganizationError;
            body: PostGithubSetDeafultOrganizationBody;
        };
    };
    getGithubPlayground: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetGithubPlaygroundParameters | void): ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): UseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, TPageParam, GetGithubPlaygroundError>): Promise<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, TPageParam, GetGithubPlaygroundError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetGithubPlaygroundParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, TPageParam, GetGithubPlaygroundError>): Promise<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | void): Promise<GetGithubPlaygroundData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | void): Promise<GetGithubPlaygroundData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void)): OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>,
            data: NoInfer<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>,
            data: GetGithubPlaygroundData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void)): GetGithubPlaygroundData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void)): QueryState<GetGithubPlaygroundData, GetGithubPlaygroundError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetGithubPlaygroundParameters | ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | void): QueryState<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGithubPlaygroundParameters, TMeta, TSignal> | void), client?: (schema: GetGithubPlaygroundSchema, options: {
            parameters: GetGithubPlaygroundParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetGithubPlaygroundData, GetGithubPlaygroundError>>): Promise<RequestFnResponse<GetGithubPlaygroundData, GetGithubPlaygroundError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetGithubPlaygroundParameters | ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>> | undefined, NoInfer<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, updater: Updater<NoInfer<GetGithubPlaygroundData> | undefined, NoInfer<GetGithubPlaygroundData> | undefined>, options?: SetDataOptions): Array<GetGithubPlaygroundData | undefined>;
        /**/
        setQueryData(parameters: (GetGithubPlaygroundParameters | undefined) | ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, updater: Updater<NoInfer<GetGithubPlaygroundData> | undefined, NoInfer<GetGithubPlaygroundData> | undefined>, options?: SetDataOptions): GetGithubPlaygroundData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetGithubPlaygroundParameters | void): ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubPlayground.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters, TData = GetGithubPlaygroundData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, OperationInfiniteData<TData, GetGithubPlaygroundParameters>, ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubPlaygroundData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubPlayground.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters, TData = GetGithubPlaygroundData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, OperationInfiniteData<TData, GetGithubPlaygroundParameters>, ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubPlaygroundData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getGithubPlaygroundTotal = qraft.v1Service.getGithubPlayground.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getGithubPlaygroundResults = qraft.v1Service.getGithubPlayground.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubPlaygroundResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getGithubPlaygroundCombinedResults = qraft.v1Service.getGithubPlayground.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubPlaygroundCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters, GetGithubPlaygroundData, GetGithubPlaygroundError>>, TCombinedResult = Array<UseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetGithubPlaygroundParameters | void): ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): UseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubPlayground.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters, TData = GetGithubPlaygroundData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundData, ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubPlaygroundData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters, GetGithubPlaygroundData, GetGithubPlaygroundError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options?: Omit<UseSuspenseQueryOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetGithubPlaygroundError | Error>;
        schema: GetGithubPlaygroundSchema;
        types: {
            parameters: GetGithubPlaygroundParameters;
            data: GetGithubPlaygroundData;
            error: GetGithubPlaygroundError;
        };
    };
    get: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetParameters | void): ServiceOperationQueryKey<GetSchema, GetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options?: Omit<UndefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): UseQueryResult<TData, GetError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<DefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetSchema, GetData, GetParameters, TPageParam, GetError>): Promise<OperationInfiniteData<GetData, GetParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetSchema, GetData, GetParameters, TPageParam, GetError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetSchema, GetData, GetParameters, TPageParam, GetError>): Promise<OperationInfiniteData<GetData, GetParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetSchema, GetData, GetParameters, GetError> | void): Promise<GetData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetSchema, GetData, GetParameters, GetError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetSchema, GetData, GetParameters, GetError> | void): Promise<GetData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void)): OperationInfiniteData<GetData, GetParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>,
            data: NoInfer<OperationInfiniteData<GetData, GetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetSchema, GetParameters>,
            data: GetData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void)): GetData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void)): QueryState<GetData, GetError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetParameters | ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | void): QueryState<OperationInfiniteData<GetData, GetParameters>, GetError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetSchema, GetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetParameters, TMeta, TSignal> | void), client?: (schema: GetSchema, options: {
            parameters: GetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetData, GetError>>): Promise<RequestFnResponse<GetData, GetError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetParameters | ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetData, GetParameters>> | undefined, NoInfer<OperationInfiniteData<GetData, GetParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetData, GetParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, updater: Updater<NoInfer<GetData> | undefined, NoInfer<GetData> | undefined>, options?: SetDataOptions): Array<GetData | undefined>;
        /**/
        setQueryData(parameters: (GetParameters | undefined) | ServiceOperationQueryKey<GetSchema, GetParameters>, updater: Updater<NoInfer<GetData> | undefined, NoInfer<GetData> | undefined>, options?: SetDataOptions): GetData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetParameters | void): ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.get.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetParameters, TData = GetData>(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetData, GetError, OperationInfiniteData<TData, GetParameters>, ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetParameters>, GetError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.get.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetParameters, TData = GetData>(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetData, GetError, OperationInfiniteData<TData, GetParameters>, ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetParameters>, GetError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getTotal = qraft.v1Service.get.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getResults = qraft.v1Service.get.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCombinedResults = qraft.v1Service.get.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetSchema, GetParameters, GetData, GetError>>, TCombinedResult = Array<UseQueryResult<GetData, GetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetData, GetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetParameters | void): ServiceOperationQueryKey<GetSchema, GetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options?: Omit<UndefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): UseQueryResult<TData, GetError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<DefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.get.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetParameters, TData = GetData>(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetData, GetError, OperationInfiniteData<TData, GetParameters>, GetData, ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetParameters>, GetError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetSchema, GetParameters, GetData, GetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetData, GetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetData, GetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options?: Omit<UseSuspenseQueryOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetError | Error>;
        schema: GetSchema;
        types: {
            parameters: GetParameters;
            data: GetData;
            error: GetError;
        };
    };
    getEnv: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetEnvParameters | void): ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getEnv.useQuery()
         * ```
         */
        useQuery<TData = GetEnvData>(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options?: Omit<UndefinedInitialDataOptions<GetEnvData, GetEnvError, TData, ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>>, "queryKey">): UseQueryResult<TData, GetEnvError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getEnv.useQuery()
         * ```
         */
        useQuery<TData = GetEnvData>(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options: Omit<DefinedInitialDataOptions<GetEnvData, GetEnvError, TData, ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetEnvError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetEnvParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetEnvSchema, GetEnvData, GetEnvParameters, TPageParam, GetEnvError>): Promise<OperationInfiniteData<GetEnvData, GetEnvParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetEnvParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetEnvSchema, GetEnvData, GetEnvParameters, TPageParam, GetEnvError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetEnvParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetEnvSchema, GetEnvData, GetEnvParameters, TPageParam, GetEnvError>): Promise<OperationInfiniteData<GetEnvData, GetEnvParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetEnvSchema, GetEnvData, GetEnvParameters, GetEnvError> | void): Promise<GetEnvData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetEnvSchema, GetEnvData, GetEnvParameters, GetEnvError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetEnvSchema, GetEnvData, GetEnvParameters, GetEnvError> | void): Promise<GetEnvData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void)): OperationInfiniteData<GetEnvData, GetEnvParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters>,
            data: NoInfer<OperationInfiniteData<GetEnvData, GetEnvParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>,
            data: GetEnvData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void)): GetEnvData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void)): QueryState<GetEnvData, GetEnvError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetEnvParameters | ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters> | void): QueryState<OperationInfiniteData<GetEnvData, GetEnvParameters>, GetEnvError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetEnvSchema, GetEnvParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetEnvParameters, TMeta, TSignal> | void), client?: (schema: GetEnvSchema, options: {
            parameters: GetEnvParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetEnvData, GetEnvError>>): Promise<RequestFnResponse<GetEnvData, GetEnvError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetEnvParameters | ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetEnvData, GetEnvParameters>> | undefined, NoInfer<OperationInfiniteData<GetEnvData, GetEnvParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetEnvData, GetEnvParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>, updater: Updater<NoInfer<GetEnvData> | undefined, NoInfer<GetEnvData> | undefined>, options?: SetDataOptions): Array<GetEnvData | undefined>;
        /**/
        setQueryData(parameters: (GetEnvParameters | undefined) | ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>, updater: Updater<NoInfer<GetEnvData> | undefined, NoInfer<GetEnvData> | undefined>, options?: SetDataOptions): GetEnvData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetEnvParameters | void): ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getEnv.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetEnvParameters, TData = GetEnvData>(parameters: ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetEnvData, GetEnvError, OperationInfiniteData<TData, GetEnvParameters>, ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetEnvData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetEnvParameters>, GetEnvError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getEnv.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetEnvParameters, TData = GetEnvData>(parameters: ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetEnvData, GetEnvError, OperationInfiniteData<TData, GetEnvParameters>, ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetEnvData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetEnvParameters>, GetEnvError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getEnvTotal = qraft.v1Service.getEnv.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError> | QueryFiltersByQueryKey<GetEnvSchema, GetEnvData, TInfinite, GetEnvParameters, GetEnvError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getEnvResults = qraft.v1Service.getEnv.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getEnvResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getEnvCombinedResults = qraft.v1Service.getEnv.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getEnvCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetEnvSchema, GetEnvParameters, GetEnvData, GetEnvError>>, TCombinedResult = Array<UseQueryResult<GetEnvData, GetEnvError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetEnvData, GetEnvError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetEnvParameters | void): ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getEnv.useQuery()
         * ```
         */
        useQuery<TData = GetEnvData>(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options?: Omit<UndefinedInitialDataOptions<GetEnvData, GetEnvError, TData, ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>>, "queryKey">): UseQueryResult<TData, GetEnvError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getEnv.useQuery()
         * ```
         */
        useQuery<TData = GetEnvData>(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options: Omit<DefinedInitialDataOptions<GetEnvData, GetEnvError, TData, ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetEnvError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getEnv.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetEnvParameters, TData = GetEnvData>(parameters: ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetEnvData, GetEnvError, OperationInfiniteData<TData, GetEnvParameters>, GetEnvData, ServiceOperationInfiniteQueryKey<GetEnvSchema, GetEnvParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetEnvData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetEnvParameters>, GetEnvError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetEnvSchema, GetEnvParameters, GetEnvData, GetEnvError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetEnvData, GetEnvError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetEnvData, GetEnvError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetEnvData>(parameters: ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters> | (GetEnvParameters | void), options?: Omit<UseSuspenseQueryOptions<GetEnvData, GetEnvError, TData, ServiceOperationQueryKey<GetEnvSchema, GetEnvParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetEnvError | Error>;
        schema: GetEnvSchema;
        types: {
            parameters: GetEnvParameters;
            data: GetEnvData;
            error: GetEnvError;
        };
    };
    putHostingDeploymentsDeploymentIdStatus: {
        /**/
        getMutationKey(parameters: PutHostingDeploymentsDeploymentIdStatusParameters | void): ServiceOperationMutationKey<PutHostingDeploymentsDeploymentIdStatusSchema, PutHostingDeploymentsDeploymentIdStatusParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useMutation({
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PutHostingDeploymentsDeploymentIdStatusBody, TContext = unknown>(parameters: PutHostingDeploymentsDeploymentIdStatusParameters, options?: ServiceOperationUseMutationOptions<PutHostingDeploymentsDeploymentIdStatusSchema, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, TVariables, PutHostingDeploymentsDeploymentIdStatusError, TContext>): UseMutationResult<PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useMutation({
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutHostingDeploymentsDeploymentIdStatusSchema, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, TVariables, PutHostingDeploymentsDeploymentIdStatusError, TContext>): UseMutationResult<PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putHostingDeploymentsDeploymentIdStatusTotal = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putHostingDeploymentsDeploymentIdStatusTotal = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useIsMutating({
         *     parameters: {
         *         path: {
         *             deploymentId: deploymentId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, PutHostingDeploymentsDeploymentIdStatusError, TContext> | MutationFiltersByMutationKey<PutHostingDeploymentsDeploymentIdStatusSchema, PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, PutHostingDeploymentsDeploymentIdStatusError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, PutHostingDeploymentsDeploymentIdStatusError, TContext> | MutationFiltersByMutationKey<PutHostingDeploymentsDeploymentIdStatusSchema, PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, PutHostingDeploymentsDeploymentIdStatusError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusParameters>, client?: (schema: PutHostingDeploymentsDeploymentIdStatusSchema, options: ServiceOperationMutationFnOptions<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusParameters>) => Promise<RequestFnResponse<PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusError>>): Promise<RequestFnResponse<PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putHostingDeploymentsDeploymentIdStatusPendingMutationVariables = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putHostingDeploymentsDeploymentIdStatusMutationData = qraft.v1Service.putHostingDeploymentsDeploymentIdStatus.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 deploymentId: deploymentId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusError, MutationVariables<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, PutHostingDeploymentsDeploymentIdStatusError, TContext> | MutationFiltersByMutationKey<PutHostingDeploymentsDeploymentIdStatusSchema, PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusParameters, PutHostingDeploymentsDeploymentIdStatusError, TContext>;
            select?: (mutation: Mutation<PutHostingDeploymentsDeploymentIdStatusData, PutHostingDeploymentsDeploymentIdStatusError, MutationVariables<PutHostingDeploymentsDeploymentIdStatusBody, PutHostingDeploymentsDeploymentIdStatusParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutHostingDeploymentsDeploymentIdStatusSchema;
        types: {
            parameters: PutHostingDeploymentsDeploymentIdStatusParameters;
            data: PutHostingDeploymentsDeploymentIdStatusData;
            error: PutHostingDeploymentsDeploymentIdStatusError;
            body: PutHostingDeploymentsDeploymentIdStatusBody;
        };
    };
    postHostingDeploymentsDeploymentIdLogs: {
        /**/
        getMutationKey(parameters: PostHostingDeploymentsDeploymentIdLogsParameters | void): ServiceOperationMutationKey<PostHostingDeploymentsDeploymentIdLogsSchema, PostHostingDeploymentsDeploymentIdLogsParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useMutation({
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostHostingDeploymentsDeploymentIdLogsBody, TContext = unknown>(parameters: PostHostingDeploymentsDeploymentIdLogsParameters, options?: ServiceOperationUseMutationOptions<PostHostingDeploymentsDeploymentIdLogsSchema, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, TVariables, PostHostingDeploymentsDeploymentIdLogsError, TContext>): UseMutationResult<PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useMutation({
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         deploymentId: deploymentId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostHostingDeploymentsDeploymentIdLogsSchema, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, TVariables, PostHostingDeploymentsDeploymentIdLogsError, TContext>): UseMutationResult<PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postHostingDeploymentsDeploymentIdLogsTotal = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postHostingDeploymentsDeploymentIdLogsTotal = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useIsMutating({
         *     parameters: {
         *         path: {
         *             deploymentId: deploymentId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, PostHostingDeploymentsDeploymentIdLogsError, TContext> | MutationFiltersByMutationKey<PostHostingDeploymentsDeploymentIdLogsSchema, PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, PostHostingDeploymentsDeploymentIdLogsError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, PostHostingDeploymentsDeploymentIdLogsError, TContext> | MutationFiltersByMutationKey<PostHostingDeploymentsDeploymentIdLogsSchema, PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, PostHostingDeploymentsDeploymentIdLogsError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsParameters>, client?: (schema: PostHostingDeploymentsDeploymentIdLogsSchema, options: ServiceOperationMutationFnOptions<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsParameters>) => Promise<RequestFnResponse<PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsError>>): Promise<RequestFnResponse<PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postHostingDeploymentsDeploymentIdLogsPendingMutationVariables = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postHostingDeploymentsDeploymentIdLogsMutationData = qraft.v1Service.postHostingDeploymentsDeploymentIdLogs.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 deploymentId: deploymentId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsError, MutationVariables<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, PostHostingDeploymentsDeploymentIdLogsError, TContext> | MutationFiltersByMutationKey<PostHostingDeploymentsDeploymentIdLogsSchema, PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsParameters, PostHostingDeploymentsDeploymentIdLogsError, TContext>;
            select?: (mutation: Mutation<PostHostingDeploymentsDeploymentIdLogsData, PostHostingDeploymentsDeploymentIdLogsError, MutationVariables<PostHostingDeploymentsDeploymentIdLogsBody, PostHostingDeploymentsDeploymentIdLogsParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostHostingDeploymentsDeploymentIdLogsSchema;
        types: {
            parameters: PostHostingDeploymentsDeploymentIdLogsParameters;
            data: PostHostingDeploymentsDeploymentIdLogsData;
            error: PostHostingDeploymentsDeploymentIdLogsError;
            body: PostHostingDeploymentsDeploymentIdLogsBody;
        };
    };
    getHostingProjectsProjectIdDomains: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetHostingProjectsProjectIdDomainsParameters): ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options?: Omit<UndefinedInitialDataOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>>, "queryKey">): UseQueryResult<TData, GetHostingProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options: Omit<DefinedInitialDataOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetHostingProjectsProjectIdDomainsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdDomainsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters, TPageParam, GetHostingProjectsProjectIdDomainsError>): Promise<OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdDomainsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters, TPageParam, GetHostingProjectsProjectIdDomainsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetHostingProjectsProjectIdDomainsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters, TPageParam, GetHostingProjectsProjectIdDomainsError>): Promise<OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): Promise<GetHostingProjectsProjectIdDomainsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): Promise<GetHostingProjectsProjectIdDomainsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters)): OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>,
            data: NoInfer<OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>,
            data: GetHostingProjectsProjectIdDomainsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters)): GetHostingProjectsProjectIdDomainsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters)): QueryState<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetHostingProjectsProjectIdDomainsParameters | ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>): QueryState<OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters>, GetHostingProjectsProjectIdDomainsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetHostingProjectsProjectIdDomainsParameters, TMeta, TSignal>), client?: (schema: GetHostingProjectsProjectIdDomainsSchema, options: {
            parameters: GetHostingProjectsProjectIdDomainsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>): Promise<RequestFnResponse<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetHostingProjectsProjectIdDomainsParameters | ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters>> | undefined, NoInfer<OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>, updater: Updater<NoInfer<GetHostingProjectsProjectIdDomainsData> | undefined, NoInfer<GetHostingProjectsProjectIdDomainsData> | undefined>, options?: SetDataOptions): Array<GetHostingProjectsProjectIdDomainsData | undefined>;
        /**/
        setQueryData(parameters: (GetHostingProjectsProjectIdDomainsParameters) | ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>, updater: Updater<NoInfer<GetHostingProjectsProjectIdDomainsData> | undefined, NoInfer<GetHostingProjectsProjectIdDomainsData> | undefined>, options?: SetDataOptions): GetHostingProjectsProjectIdDomainsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetHostingProjectsProjectIdDomainsParameters): ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getHostingProjectsProjectIdDomains.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdDomainsParameters, TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, OperationInfiniteData<TData, GetHostingProjectsProjectIdDomainsParameters>, ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetHostingProjectsProjectIdDomainsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetHostingProjectsProjectIdDomainsParameters>, GetHostingProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getHostingProjectsProjectIdDomains.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdDomainsParameters, TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, OperationInfiniteData<TData, GetHostingProjectsProjectIdDomainsParameters>, ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetHostingProjectsProjectIdDomainsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetHostingProjectsProjectIdDomainsParameters>, GetHostingProjectsProjectIdDomainsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getHostingProjectsProjectIdDomainsTotal = qraft.v1Service.getHostingProjectsProjectIdDomains.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getHostingProjectsProjectIdDomainsByParametersTotal = qraft.v1Service.getHostingProjectsProjectIdDomains.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsData, TInfinite, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getHostingProjectsProjectIdDomainsResults = qraft.v1Service.getHostingProjectsProjectIdDomains.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getHostingProjectsProjectIdDomainsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getHostingProjectsProjectIdDomainsCombinedResults = qraft.v1Service.getHostingProjectsProjectIdDomains.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getHostingProjectsProjectIdDomainsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>, TCombinedResult = Array<UseQueryResult<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetHostingProjectsProjectIdDomainsParameters): ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options?: Omit<UndefinedInitialDataOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>>, "queryKey">): UseQueryResult<TData, GetHostingProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options: Omit<DefinedInitialDataOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetHostingProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getHostingProjectsProjectIdDomains.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdDomainsParameters, TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, OperationInfiniteData<TData, GetHostingProjectsProjectIdDomainsParameters>, GetHostingProjectsProjectIdDomainsData, ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetHostingProjectsProjectIdDomainsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetHostingProjectsProjectIdDomainsParameters>, GetHostingProjectsProjectIdDomainsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters, GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetHostingProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters> | (GetHostingProjectsProjectIdDomainsParameters), options?: Omit<UseSuspenseQueryOptions<GetHostingProjectsProjectIdDomainsData, GetHostingProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdDomainsSchema, GetHostingProjectsProjectIdDomainsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetHostingProjectsProjectIdDomainsError | Error>;
        schema: GetHostingProjectsProjectIdDomainsSchema;
        types: {
            parameters: GetHostingProjectsProjectIdDomainsParameters;
            data: GetHostingProjectsProjectIdDomainsData;
            error: GetHostingProjectsProjectIdDomainsError;
        };
    };
    getHostingProjectsProjectIdEnvironment: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetHostingProjectsProjectIdEnvironmentParameters): ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options?: Omit<UndefinedInitialDataOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>>, "queryKey">): UseQueryResult<TData, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options: Omit<DefinedInitialDataOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdEnvironmentParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters, TPageParam, GetHostingProjectsProjectIdEnvironmentError>): Promise<OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdEnvironmentParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters, TPageParam, GetHostingProjectsProjectIdEnvironmentError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetHostingProjectsProjectIdEnvironmentParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters, TPageParam, GetHostingProjectsProjectIdEnvironmentError>): Promise<OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): Promise<GetHostingProjectsProjectIdEnvironmentData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): Promise<GetHostingProjectsProjectIdEnvironmentData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters)): OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>,
            data: NoInfer<OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>,
            data: GetHostingProjectsProjectIdEnvironmentData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters)): GetHostingProjectsProjectIdEnvironmentData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters)): QueryState<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetHostingProjectsProjectIdEnvironmentParameters | ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>): QueryState<OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters>, GetHostingProjectsProjectIdEnvironmentError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetHostingProjectsProjectIdEnvironmentParameters, TMeta, TSignal>), client?: (schema: GetHostingProjectsProjectIdEnvironmentSchema, options: {
            parameters: GetHostingProjectsProjectIdEnvironmentParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>): Promise<RequestFnResponse<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetHostingProjectsProjectIdEnvironmentParameters | ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters>> | undefined, NoInfer<OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>, updater: Updater<NoInfer<GetHostingProjectsProjectIdEnvironmentData> | undefined, NoInfer<GetHostingProjectsProjectIdEnvironmentData> | undefined>, options?: SetDataOptions): Array<GetHostingProjectsProjectIdEnvironmentData | undefined>;
        /**/
        setQueryData(parameters: (GetHostingProjectsProjectIdEnvironmentParameters) | ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>, updater: Updater<NoInfer<GetHostingProjectsProjectIdEnvironmentData> | undefined, NoInfer<GetHostingProjectsProjectIdEnvironmentData> | undefined>, options?: SetDataOptions): GetHostingProjectsProjectIdEnvironmentData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetHostingProjectsProjectIdEnvironmentParameters): ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             branch: initialBranch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdEnvironmentParameters, TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, OperationInfiniteData<TData, GetHostingProjectsProjectIdEnvironmentParameters>, ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetHostingProjectsProjectIdEnvironmentData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetHostingProjectsProjectIdEnvironmentParameters>, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             branch: initialBranch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdEnvironmentParameters, TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, OperationInfiniteData<TData, GetHostingProjectsProjectIdEnvironmentParameters>, ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetHostingProjectsProjectIdEnvironmentData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetHostingProjectsProjectIdEnvironmentParameters>, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getHostingProjectsProjectIdEnvironmentTotal = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getHostingProjectsProjectIdEnvironmentByParametersTotal = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         },
         *         query: {
         *             branch: branch
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentData, TInfinite, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getHostingProjectsProjectIdEnvironmentResults = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             },
         *             query: {
         *                 branch: branch1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             },
         *             query: {
         *                 branch: branch2
         *             }
         *         }
         *     ]
         * });
         * getHostingProjectsProjectIdEnvironmentResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getHostingProjectsProjectIdEnvironmentCombinedResults = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             },
         *             query: {
         *                 branch: branch1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             },
         *             query: {
         *                 branch: branch2
         *             }
         *         }
         *     ]
         * });
         * getHostingProjectsProjectIdEnvironmentCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>, TCombinedResult = Array<UseQueryResult<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetHostingProjectsProjectIdEnvironmentParameters): ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options?: Omit<UndefinedInitialDataOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>>, "queryKey">): UseQueryResult<TData, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options: Omit<DefinedInitialDataOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getHostingProjectsProjectIdEnvironment.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             branch: initialBranch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetHostingProjectsProjectIdEnvironmentParameters, TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, OperationInfiniteData<TData, GetHostingProjectsProjectIdEnvironmentParameters>, GetHostingProjectsProjectIdEnvironmentData, ServiceOperationInfiniteQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetHostingProjectsProjectIdEnvironmentData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetHostingProjectsProjectIdEnvironmentParameters>, GetHostingProjectsProjectIdEnvironmentError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters, GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetHostingProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters> | (GetHostingProjectsProjectIdEnvironmentParameters), options?: Omit<UseSuspenseQueryOptions<GetHostingProjectsProjectIdEnvironmentData, GetHostingProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetHostingProjectsProjectIdEnvironmentSchema, GetHostingProjectsProjectIdEnvironmentParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetHostingProjectsProjectIdEnvironmentError | Error>;
        schema: GetHostingProjectsProjectIdEnvironmentSchema;
        types: {
            parameters: GetHostingProjectsProjectIdEnvironmentParameters;
            data: GetHostingProjectsProjectIdEnvironmentData;
            error: GetHostingProjectsProjectIdEnvironmentError;
        };
    };
    putHostingProjectsProjectIdState: {
        /**/
        getMutationKey(parameters: PutHostingProjectsProjectIdStateParameters | void): ServiceOperationMutationKey<PutHostingProjectsProjectIdStateSchema, PutHostingProjectsProjectIdStateParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingProjectsProjectIdState.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingProjectsProjectIdState.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PutHostingProjectsProjectIdStateBody, TContext = unknown>(parameters: PutHostingProjectsProjectIdStateParameters, options?: ServiceOperationUseMutationOptions<PutHostingProjectsProjectIdStateSchema, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, TVariables, PutHostingProjectsProjectIdStateError, TContext>): UseMutationResult<PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingProjectsProjectIdState.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putHostingProjectsProjectIdState.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutHostingProjectsProjectIdStateSchema, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, TVariables, PutHostingProjectsProjectIdStateError, TContext>): UseMutationResult<PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putHostingProjectsProjectIdStateTotal = qraft.v1Service.putHostingProjectsProjectIdState.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putHostingProjectsProjectIdStateTotal = qraft.v1Service.putHostingProjectsProjectIdState.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, PutHostingProjectsProjectIdStateError, TContext> | MutationFiltersByMutationKey<PutHostingProjectsProjectIdStateSchema, PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, PutHostingProjectsProjectIdStateError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, PutHostingProjectsProjectIdStateError, TContext> | MutationFiltersByMutationKey<PutHostingProjectsProjectIdStateSchema, PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, PutHostingProjectsProjectIdStateError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateParameters>, client?: (schema: PutHostingProjectsProjectIdStateSchema, options: ServiceOperationMutationFnOptions<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateParameters>) => Promise<RequestFnResponse<PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateError>>): Promise<RequestFnResponse<PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putHostingProjectsProjectIdStatePendingMutationVariables = qraft.v1Service.putHostingProjectsProjectIdState.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putHostingProjectsProjectIdStateMutationData = qraft.v1Service.putHostingProjectsProjectIdState.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateError, MutationVariables<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, PutHostingProjectsProjectIdStateError, TContext> | MutationFiltersByMutationKey<PutHostingProjectsProjectIdStateSchema, PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateParameters, PutHostingProjectsProjectIdStateError, TContext>;
            select?: (mutation: Mutation<PutHostingProjectsProjectIdStateData, PutHostingProjectsProjectIdStateError, MutationVariables<PutHostingProjectsProjectIdStateBody, PutHostingProjectsProjectIdStateParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutHostingProjectsProjectIdStateSchema;
        types: {
            parameters: PutHostingProjectsProjectIdStateParameters;
            data: PutHostingProjectsProjectIdStateData;
            error: PutHostingProjectsProjectIdStateError;
            body: PutHostingProjectsProjectIdStateBody;
        };
    };
    postHostingProjectsProjectIdServices: {
        /**/
        getMutationKey(parameters: PostHostingProjectsProjectIdServicesParameters | void): ServiceOperationMutationKey<PostHostingProjectsProjectIdServicesSchema, PostHostingProjectsProjectIdServicesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingProjectsProjectIdServices.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingProjectsProjectIdServices.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostHostingProjectsProjectIdServicesBody, TContext = unknown>(parameters: PostHostingProjectsProjectIdServicesParameters, options?: ServiceOperationUseMutationOptions<PostHostingProjectsProjectIdServicesSchema, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, TVariables, PostHostingProjectsProjectIdServicesError, TContext>): UseMutationResult<PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingProjectsProjectIdServices.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postHostingProjectsProjectIdServices.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostHostingProjectsProjectIdServicesSchema, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, TVariables, PostHostingProjectsProjectIdServicesError, TContext>): UseMutationResult<PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postHostingProjectsProjectIdServicesTotal = qraft.v1Service.postHostingProjectsProjectIdServices.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postHostingProjectsProjectIdServicesTotal = qraft.v1Service.postHostingProjectsProjectIdServices.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, PostHostingProjectsProjectIdServicesError, TContext> | MutationFiltersByMutationKey<PostHostingProjectsProjectIdServicesSchema, PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, PostHostingProjectsProjectIdServicesError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, PostHostingProjectsProjectIdServicesError, TContext> | MutationFiltersByMutationKey<PostHostingProjectsProjectIdServicesSchema, PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, PostHostingProjectsProjectIdServicesError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesParameters>, client?: (schema: PostHostingProjectsProjectIdServicesSchema, options: ServiceOperationMutationFnOptions<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesParameters>) => Promise<RequestFnResponse<PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesError>>): Promise<RequestFnResponse<PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postHostingProjectsProjectIdServicesPendingMutationVariables = qraft.v1Service.postHostingProjectsProjectIdServices.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postHostingProjectsProjectIdServicesMutationData = qraft.v1Service.postHostingProjectsProjectIdServices.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesError, MutationVariables<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, PostHostingProjectsProjectIdServicesError, TContext> | MutationFiltersByMutationKey<PostHostingProjectsProjectIdServicesSchema, PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesParameters, PostHostingProjectsProjectIdServicesError, TContext>;
            select?: (mutation: Mutation<PostHostingProjectsProjectIdServicesData, PostHostingProjectsProjectIdServicesError, MutationVariables<PostHostingProjectsProjectIdServicesBody, PostHostingProjectsProjectIdServicesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostHostingProjectsProjectIdServicesSchema;
        types: {
            parameters: PostHostingProjectsProjectIdServicesParameters;
            data: PostHostingProjectsProjectIdServicesData;
            error: PostHostingProjectsProjectIdServicesError;
            body: PostHostingProjectsProjectIdServicesBody;
        };
    };
    postMailSend: {
        /**/
        getMutationKey(parameters: PostMailSendParameters | void): ServiceOperationMutationKey<PostMailSendSchema, PostMailSendParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postMailSend.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postMailSend.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostMailSendBody, TContext = unknown>(parameters: PostMailSendParameters, options?: ServiceOperationUseMutationOptions<PostMailSendSchema, PostMailSendData, PostMailSendParameters, TVariables, PostMailSendError, TContext>): UseMutationResult<PostMailSendData, PostMailSendError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postMailSend.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postMailSend.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostMailSendBody, PostMailSendParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostMailSendSchema, PostMailSendData, PostMailSendParameters, TVariables, PostMailSendError, TContext>): UseMutationResult<PostMailSendData, PostMailSendError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postMailSendTotal = qraft.v1Service.postMailSend.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postMailSendTotal = qraft.v1Service.postMailSend.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostMailSendBody, PostMailSendData, PostMailSendParameters, PostMailSendError, TContext> | MutationFiltersByMutationKey<PostMailSendSchema, PostMailSendBody, PostMailSendData, PostMailSendParameters, PostMailSendError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostMailSendBody, PostMailSendData, PostMailSendParameters, PostMailSendError, TContext> | MutationFiltersByMutationKey<PostMailSendSchema, PostMailSendBody, PostMailSendData, PostMailSendParameters, PostMailSendError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostMailSendBody, PostMailSendParameters>, client?: (schema: PostMailSendSchema, options: ServiceOperationMutationFnOptions<PostMailSendBody, PostMailSendParameters>) => Promise<RequestFnResponse<PostMailSendData, PostMailSendError>>): Promise<RequestFnResponse<PostMailSendData, PostMailSendError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postMailSendPendingMutationVariables = qraft.v1Service.postMailSend.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postMailSendMutationData = qraft.v1Service.postMailSend.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostMailSendData, PostMailSendError, MutationVariables<PostMailSendBody, PostMailSendParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostMailSendBody, PostMailSendData, PostMailSendParameters, PostMailSendError, TContext> | MutationFiltersByMutationKey<PostMailSendSchema, PostMailSendBody, PostMailSendData, PostMailSendParameters, PostMailSendError, TContext>;
            select?: (mutation: Mutation<PostMailSendData, PostMailSendError, MutationVariables<PostMailSendBody, PostMailSendParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostMailSendSchema;
        types: {
            parameters: PostMailSendParameters;
            data: PostMailSendData;
            error: PostMailSendError;
            body: PostMailSendBody;
        };
    };
    getProjectsProjectId: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdParameters): ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdSchema, GetProjectsProjectIdData, GetProjectsProjectIdParameters, TPageParam, GetProjectsProjectIdError>): Promise<OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdSchema, GetProjectsProjectIdData, GetProjectsProjectIdParameters, TPageParam, GetProjectsProjectIdError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdSchema, GetProjectsProjectIdData, GetProjectsProjectIdParameters, TPageParam, GetProjectsProjectIdError>): Promise<OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdSchema, GetProjectsProjectIdData, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): Promise<GetProjectsProjectIdData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdSchema, GetProjectsProjectIdData, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdSchema, GetProjectsProjectIdData, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): Promise<GetProjectsProjectIdData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters)): OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>,
            data: GetProjectsProjectIdData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters)): GetProjectsProjectIdData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters)): QueryState<GetProjectsProjectIdData, GetProjectsProjectIdError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters>, GetProjectsProjectIdError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdSchema, options: {
            parameters: GetProjectsProjectIdParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdData, GetProjectsProjectIdError>>): Promise<RequestFnResponse<GetProjectsProjectIdData, GetProjectsProjectIdError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdData, GetProjectsProjectIdParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>, updater: Updater<NoInfer<GetProjectsProjectIdData> | undefined, NoInfer<GetProjectsProjectIdData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdParameters) | ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>, updater: Updater<NoInfer<GetProjectsProjectIdData> | undefined, NoInfer<GetProjectsProjectIdData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectId.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdParameters, TData = GetProjectsProjectIdData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, OperationInfiniteData<TData, GetProjectsProjectIdParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdParameters>, GetProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectId.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdParameters, TData = GetProjectsProjectIdData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, OperationInfiniteData<TData, GetProjectsProjectIdParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdParameters>, GetProjectsProjectIdError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdTotal = qraft.v1Service.getProjectsProjectId.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdByParametersTotal = qraft.v1Service.getProjectsProjectId.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdData, TInfinite, GetProjectsProjectIdParameters, GetProjectsProjectIdError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdResults = qraft.v1Service.getProjectsProjectId.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdCombinedResults = qraft.v1Service.getProjectsProjectId.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters, GetProjectsProjectIdData, GetProjectsProjectIdError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdData, GetProjectsProjectIdError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdData, GetProjectsProjectIdError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdParameters): ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectId.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectId.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdParameters, TData = GetProjectsProjectIdData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, OperationInfiniteData<TData, GetProjectsProjectIdParameters>, GetProjectsProjectIdData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdParameters>, GetProjectsProjectIdError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters, GetProjectsProjectIdData, GetProjectsProjectIdError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdData, GetProjectsProjectIdError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdData, GetProjectsProjectIdError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters> | (GetProjectsProjectIdParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdData, GetProjectsProjectIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdSchema, GetProjectsProjectIdParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdError | Error>;
        schema: GetProjectsProjectIdSchema;
        types: {
            parameters: GetProjectsProjectIdParameters;
            data: GetProjectsProjectIdData;
            error: GetProjectsProjectIdError;
        };
    };
    deleteProjectsProjectId: {
        /**/
        getMutationKey(parameters: DeleteProjectsProjectIdParameters | void): ServiceOperationMutationKey<DeleteProjectsProjectIdSchema, DeleteProjectsProjectIdParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectId.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectId.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteProjectsProjectIdBody, TContext = unknown>(parameters: DeleteProjectsProjectIdParameters, options?: ServiceOperationUseMutationOptions<DeleteProjectsProjectIdSchema, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, TVariables, DeleteProjectsProjectIdError, TContext>): UseMutationResult<DeleteProjectsProjectIdData, DeleteProjectsProjectIdError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectId.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectId.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteProjectsProjectIdSchema, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, TVariables, DeleteProjectsProjectIdError, TContext>): UseMutationResult<DeleteProjectsProjectIdData, DeleteProjectsProjectIdError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteProjectsProjectIdTotal = qraft.v1Service.deleteProjectsProjectId.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteProjectsProjectIdTotal = qraft.v1Service.deleteProjectsProjectId.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, DeleteProjectsProjectIdError, TContext> | MutationFiltersByMutationKey<DeleteProjectsProjectIdSchema, DeleteProjectsProjectIdBody, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, DeleteProjectsProjectIdError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, DeleteProjectsProjectIdError, TContext> | MutationFiltersByMutationKey<DeleteProjectsProjectIdSchema, DeleteProjectsProjectIdBody, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, DeleteProjectsProjectIdError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdParameters>, client?: (schema: DeleteProjectsProjectIdSchema, options: ServiceOperationMutationFnOptions<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdParameters>) => Promise<RequestFnResponse<DeleteProjectsProjectIdData, DeleteProjectsProjectIdError>>): Promise<RequestFnResponse<DeleteProjectsProjectIdData, DeleteProjectsProjectIdError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteProjectsProjectIdPendingMutationVariables = qraft.v1Service.deleteProjectsProjectId.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteProjectsProjectIdMutationData = qraft.v1Service.deleteProjectsProjectId.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteProjectsProjectIdData, DeleteProjectsProjectIdError, MutationVariables<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, DeleteProjectsProjectIdError, TContext> | MutationFiltersByMutationKey<DeleteProjectsProjectIdSchema, DeleteProjectsProjectIdBody, DeleteProjectsProjectIdData, DeleteProjectsProjectIdParameters, DeleteProjectsProjectIdError, TContext>;
            select?: (mutation: Mutation<DeleteProjectsProjectIdData, DeleteProjectsProjectIdError, MutationVariables<DeleteProjectsProjectIdBody, DeleteProjectsProjectIdParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteProjectsProjectIdSchema;
        types: {
            parameters: DeleteProjectsProjectIdParameters;
            data: DeleteProjectsProjectIdData;
            error: DeleteProjectsProjectIdError;
            body: DeleteProjectsProjectIdBody;
        };
    };
    getProjectsProjectIdStart: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdStartParameters): ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStart.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdStartError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStart.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdStartError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdStartParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters, TPageParam, GetProjectsProjectIdStartError>): Promise<OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdStartParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters, TPageParam, GetProjectsProjectIdStartError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdStartParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters, TPageParam, GetProjectsProjectIdStartError>): Promise<OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): Promise<GetProjectsProjectIdStartData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): Promise<GetProjectsProjectIdStartData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters)): OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>,
            data: GetProjectsProjectIdStartData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters)): GetProjectsProjectIdStartData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters)): QueryState<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdStartParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters>, GetProjectsProjectIdStartError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdStartParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdStartSchema, options: {
            parameters: GetProjectsProjectIdStartParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>): Promise<RequestFnResponse<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdStartParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdStartData, GetProjectsProjectIdStartParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>, updater: Updater<NoInfer<GetProjectsProjectIdStartData> | undefined, NoInfer<GetProjectsProjectIdStartData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdStartData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdStartParameters) | ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>, updater: Updater<NoInfer<GetProjectsProjectIdStartData> | undefined, NoInfer<GetProjectsProjectIdStartData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdStartData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdStartParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdStart.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdStartParameters, TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, OperationInfiniteData<TData, GetProjectsProjectIdStartParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdStartData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdStartParameters>, GetProjectsProjectIdStartError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdStart.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdStartParameters, TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, OperationInfiniteData<TData, GetProjectsProjectIdStartParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdStartData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdStartParameters>, GetProjectsProjectIdStartError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdStartTotal = qraft.v1Service.getProjectsProjectIdStart.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdStartByParametersTotal = qraft.v1Service.getProjectsProjectIdStart.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError> | QueryFiltersByQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartData, TInfinite, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdStartResults = qraft.v1Service.getProjectsProjectIdStart.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdStartResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdStartCombinedResults = qraft.v1Service.getProjectsProjectIdStart.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdStartCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdStartParameters): ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStart.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdStartError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStart.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdStartError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdStart.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdStartParameters, TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, OperationInfiniteData<TData, GetProjectsProjectIdStartParameters>, GetProjectsProjectIdStartData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdStartData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdStartParameters>, GetProjectsProjectIdStartError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters, GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdStartData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters> | (GetProjectsProjectIdStartParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdStartData, GetProjectsProjectIdStartError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStartSchema, GetProjectsProjectIdStartParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdStartError | Error>;
        schema: GetProjectsProjectIdStartSchema;
        types: {
            parameters: GetProjectsProjectIdStartParameters;
            data: GetProjectsProjectIdStartData;
            error: GetProjectsProjectIdStartError;
        };
    };
    getProjectsProjectIdStop: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdStopParameters): ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStop.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdStopError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStop.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdStopError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdStopParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters, TPageParam, GetProjectsProjectIdStopError>): Promise<OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdStopParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters, TPageParam, GetProjectsProjectIdStopError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdStopParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters, TPageParam, GetProjectsProjectIdStopError>): Promise<OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): Promise<GetProjectsProjectIdStopData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): Promise<GetProjectsProjectIdStopData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters)): OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>,
            data: GetProjectsProjectIdStopData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters)): GetProjectsProjectIdStopData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters)): QueryState<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdStopParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters>, GetProjectsProjectIdStopError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdStopParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdStopSchema, options: {
            parameters: GetProjectsProjectIdStopParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>): Promise<RequestFnResponse<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdStopParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdStopData, GetProjectsProjectIdStopParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>, updater: Updater<NoInfer<GetProjectsProjectIdStopData> | undefined, NoInfer<GetProjectsProjectIdStopData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdStopData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdStopParameters) | ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>, updater: Updater<NoInfer<GetProjectsProjectIdStopData> | undefined, NoInfer<GetProjectsProjectIdStopData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdStopData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdStopParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdStop.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdStopParameters, TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, OperationInfiniteData<TData, GetProjectsProjectIdStopParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdStopData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdStopParameters>, GetProjectsProjectIdStopError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdStop.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdStopParameters, TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, OperationInfiniteData<TData, GetProjectsProjectIdStopParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdStopData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdStopParameters>, GetProjectsProjectIdStopError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdStopTotal = qraft.v1Service.getProjectsProjectIdStop.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdStopByParametersTotal = qraft.v1Service.getProjectsProjectIdStop.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError> | QueryFiltersByQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopData, TInfinite, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdStopResults = qraft.v1Service.getProjectsProjectIdStop.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdStopResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdStopCombinedResults = qraft.v1Service.getProjectsProjectIdStop.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdStopCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdStopParameters): ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStop.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdStopError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdStop.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdStopError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdStop.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdStopParameters, TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, OperationInfiniteData<TData, GetProjectsProjectIdStopParameters>, GetProjectsProjectIdStopData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdStopData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdStopParameters>, GetProjectsProjectIdStopError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters, GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdStopData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters> | (GetProjectsProjectIdStopParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdStopData, GetProjectsProjectIdStopError, TData, ServiceOperationQueryKey<GetProjectsProjectIdStopSchema, GetProjectsProjectIdStopParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdStopError | Error>;
        schema: GetProjectsProjectIdStopSchema;
        types: {
            parameters: GetProjectsProjectIdStopParameters;
            data: GetProjectsProjectIdStopData;
            error: GetProjectsProjectIdStopError;
        };
    };
    getProjects: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsParameters | void): ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery({
         *     query: {
         *         search: search
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsData>(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetProjectsData, GetProjectsError, TData, ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery({
         *     query: {
         *         search: search
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsData>(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options: Omit<DefinedInitialDataOptions<GetProjectsData, GetProjectsError, TData, ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsSchema, GetProjectsData, GetProjectsParameters, TPageParam, GetProjectsError>): Promise<OperationInfiniteData<GetProjectsData, GetProjectsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsSchema, GetProjectsData, GetProjectsParameters, TPageParam, GetProjectsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsSchema, GetProjectsData, GetProjectsParameters, TPageParam, GetProjectsError>): Promise<OperationInfiniteData<GetProjectsData, GetProjectsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsSchema, GetProjectsData, GetProjectsParameters, GetProjectsError> | void): Promise<GetProjectsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsSchema, GetProjectsData, GetProjectsParameters, GetProjectsError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsSchema, GetProjectsData, GetProjectsParameters, GetProjectsError> | void): Promise<GetProjectsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void)): OperationInfiniteData<GetProjectsData, GetProjectsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsData, GetProjectsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>,
            data: GetProjectsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void)): GetProjectsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void)): QueryState<GetProjectsData, GetProjectsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsParameters | ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters> | void): QueryState<OperationInfiniteData<GetProjectsData, GetProjectsParameters>, GetProjectsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsSchema, GetProjectsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsParameters, TMeta, TSignal> | void), client?: (schema: GetProjectsSchema, options: {
            parameters: GetProjectsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsData, GetProjectsError>>): Promise<RequestFnResponse<GetProjectsData, GetProjectsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsParameters | ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsData, GetProjectsParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsData, GetProjectsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsData, GetProjectsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>, updater: Updater<NoInfer<GetProjectsData> | undefined, NoInfer<GetProjectsData> | undefined>, options?: SetDataOptions): Array<GetProjectsData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsParameters | undefined) | ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>, updater: Updater<NoInfer<GetProjectsData> | undefined, NoInfer<GetProjectsData> | undefined>, options?: SetDataOptions): GetProjectsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsParameters | void): ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjects.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             search: initialSearch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsParameters, TData = GetProjectsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsData, GetProjectsError, OperationInfiniteData<TData, GetProjectsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsParameters>, GetProjectsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjects.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             search: initialSearch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsParameters, TData = GetProjectsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsData, GetProjectsError, OperationInfiniteData<TData, GetProjectsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsParameters>, GetProjectsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsTotal = qraft.v1Service.getProjects.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsByParametersTotal = qraft.v1Service.getProjects.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             search: search
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError> | QueryFiltersByQueryKey<GetProjectsSchema, GetProjectsData, TInfinite, GetProjectsParameters, GetProjectsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsResults = qraft.v1Service.getProjects.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 search: search1
         *             }
         *         },
         *         {
         *             query: {
         *                 search: search2
         *             }
         *         }
         *     ]
         * });
         * getProjectsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsCombinedResults = qraft.v1Service.getProjects.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 search: search1
         *             }
         *         },
         *         {
         *             query: {
         *                 search: search2
         *             }
         *         }
         *     ]
         * });
         * getProjectsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsSchema, GetProjectsParameters, GetProjectsData, GetProjectsError>>, TCombinedResult = Array<UseQueryResult<GetProjectsData, GetProjectsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsData, GetProjectsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsParameters | void): ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery({
         *     query: {
         *         search: search
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsData>(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetProjectsData, GetProjectsError, TData, ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjects.useQuery({
         *     query: {
         *         search: search
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsData>(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options: Omit<DefinedInitialDataOptions<GetProjectsData, GetProjectsError, TData, ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjects.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             search: initialSearch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsParameters, TData = GetProjectsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsData, GetProjectsError, OperationInfiniteData<TData, GetProjectsParameters>, GetProjectsData, ServiceOperationInfiniteQueryKey<GetProjectsSchema, GetProjectsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsParameters>, GetProjectsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsSchema, GetProjectsParameters, GetProjectsData, GetProjectsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsData, GetProjectsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsData, GetProjectsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsData>(parameters: ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters> | (GetProjectsParameters | void), options?: Omit<UseSuspenseQueryOptions<GetProjectsData, GetProjectsError, TData, ServiceOperationQueryKey<GetProjectsSchema, GetProjectsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsError | Error>;
        schema: GetProjectsSchema;
        types: {
            parameters: GetProjectsParameters;
            data: GetProjectsData;
            error: GetProjectsError;
        };
    };
    getProjectsProjectIdUsageSpan: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdUsageSpanParameters): ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdUsageSpan.useQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, TData, ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdUsageSpanError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdUsageSpan.useQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, TData, ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdUsageSpanError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdUsageSpanParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters, TPageParam, GetProjectsProjectIdUsageSpanError>): Promise<OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdUsageSpanParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters, TPageParam, GetProjectsProjectIdUsageSpanError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdUsageSpanParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters, TPageParam, GetProjectsProjectIdUsageSpanError>): Promise<OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): Promise<GetProjectsProjectIdUsageSpanData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): Promise<GetProjectsProjectIdUsageSpanData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters)): OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>,
            data: GetProjectsProjectIdUsageSpanData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters)): GetProjectsProjectIdUsageSpanData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters)): QueryState<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdUsageSpanParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters>, GetProjectsProjectIdUsageSpanError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdUsageSpanParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdUsageSpanSchema, options: {
            parameters: GetProjectsProjectIdUsageSpanParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>): Promise<RequestFnResponse<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdUsageSpanParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>, updater: Updater<NoInfer<GetProjectsProjectIdUsageSpanData> | undefined, NoInfer<GetProjectsProjectIdUsageSpanData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdUsageSpanData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdUsageSpanParameters) | ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>, updater: Updater<NoInfer<GetProjectsProjectIdUsageSpanData> | undefined, NoInfer<GetProjectsProjectIdUsageSpanData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdUsageSpanData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdUsageSpanParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdUsageSpan.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdUsageSpanParameters, TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, OperationInfiniteData<TData, GetProjectsProjectIdUsageSpanParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdUsageSpanData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdUsageSpanParameters>, GetProjectsProjectIdUsageSpanError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdUsageSpan.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdUsageSpanParameters, TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, OperationInfiniteData<TData, GetProjectsProjectIdUsageSpanParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdUsageSpanData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdUsageSpanParameters>, GetProjectsProjectIdUsageSpanError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdUsageSpanTotal = qraft.v1Service.getProjectsProjectIdUsageSpan.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdUsageSpanByParametersTotal = qraft.v1Service.getProjectsProjectIdUsageSpan.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             usageSpan: usageSpan
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError> | QueryFiltersByQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanData, TInfinite, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdUsageSpanResults = qraft.v1Service.getProjectsProjectIdUsageSpan.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 usageSpan: usageSpan1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 usageSpan: usageSpan2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdUsageSpanResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdUsageSpanCombinedResults = qraft.v1Service.getProjectsProjectIdUsageSpan.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 usageSpan: usageSpan1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 usageSpan: usageSpan2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdUsageSpanCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdUsageSpanParameters): ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdUsageSpan.useQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, TData, ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdUsageSpanError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdUsageSpan.useQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, TData, ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdUsageSpanError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdUsageSpan.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         usageSpan: usageSpan
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdUsageSpanParameters, TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, OperationInfiniteData<TData, GetProjectsProjectIdUsageSpanParameters>, GetProjectsProjectIdUsageSpanData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdUsageSpanData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdUsageSpanParameters>, GetProjectsProjectIdUsageSpanError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters, GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdUsageSpanData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters> | (GetProjectsProjectIdUsageSpanParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdUsageSpanData, GetProjectsProjectIdUsageSpanError, TData, ServiceOperationQueryKey<GetProjectsProjectIdUsageSpanSchema, GetProjectsProjectIdUsageSpanParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdUsageSpanError | Error>;
        schema: GetProjectsProjectIdUsageSpanSchema;
        types: {
            parameters: GetProjectsProjectIdUsageSpanParameters;
            data: GetProjectsProjectIdUsageSpanData;
            error: GetProjectsProjectIdUsageSpanError;
        };
    };
    getProjectsProjectIdDeployments: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDeploymentsParameters): ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeployments.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         deploymentStatus: deploymentStatus
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDeploymentsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeployments.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         deploymentStatus: deploymentStatus
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDeploymentsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters, TPageParam, GetProjectsProjectIdDeploymentsError>): Promise<OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters, TPageParam, GetProjectsProjectIdDeploymentsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdDeploymentsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters, TPageParam, GetProjectsProjectIdDeploymentsError>): Promise<OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): Promise<GetProjectsProjectIdDeploymentsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): Promise<GetProjectsProjectIdDeploymentsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters)): OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>,
            data: GetProjectsProjectIdDeploymentsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters)): GetProjectsProjectIdDeploymentsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters)): QueryState<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdDeploymentsParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters>, GetProjectsProjectIdDeploymentsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdDeploymentsParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdDeploymentsSchema, options: {
            parameters: GetProjectsProjectIdDeploymentsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>): Promise<RequestFnResponse<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdDeploymentsParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>, updater: Updater<NoInfer<GetProjectsProjectIdDeploymentsData> | undefined, NoInfer<GetProjectsProjectIdDeploymentsData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdDeploymentsData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdDeploymentsParameters) | ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>, updater: Updater<NoInfer<GetProjectsProjectIdDeploymentsData> | undefined, NoInfer<GetProjectsProjectIdDeploymentsData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdDeploymentsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdDeploymentsParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeployments.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             deploymentStatus: initialDeploymentStatus
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsParameters, TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsParameters>, GetProjectsProjectIdDeploymentsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeployments.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             deploymentStatus: initialDeploymentStatus
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsParameters, TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsParameters>, GetProjectsProjectIdDeploymentsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdDeploymentsTotal = qraft.v1Service.getProjectsProjectIdDeployments.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdDeploymentsByParametersTotal = qraft.v1Service.getProjectsProjectIdDeployments.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         },
         *         query: {
         *             deploymentStatus: deploymentStatus
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsData, TInfinite, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdDeploymentsResults = qraft.v1Service.getProjectsProjectIdDeployments.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             },
         *             query: {
         *                 deploymentStatus: deploymentStatus1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             },
         *             query: {
         *                 deploymentStatus: deploymentStatus2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDeploymentsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdDeploymentsCombinedResults = qraft.v1Service.getProjectsProjectIdDeployments.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             },
         *             query: {
         *                 deploymentStatus: deploymentStatus1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             },
         *             query: {
         *                 deploymentStatus: deploymentStatus2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDeploymentsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDeploymentsParameters): ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeployments.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         deploymentStatus: deploymentStatus
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDeploymentsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeployments.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         deploymentStatus: deploymentStatus
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDeploymentsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeployments.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             deploymentStatus: initialDeploymentStatus
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsParameters, TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsParameters>, GetProjectsProjectIdDeploymentsData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsParameters>, GetProjectsProjectIdDeploymentsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters, GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdDeploymentsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters> | (GetProjectsProjectIdDeploymentsParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdDeploymentsData, GetProjectsProjectIdDeploymentsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsSchema, GetProjectsProjectIdDeploymentsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdDeploymentsError | Error>;
        schema: GetProjectsProjectIdDeploymentsSchema;
        types: {
            parameters: GetProjectsProjectIdDeploymentsParameters;
            data: GetProjectsProjectIdDeploymentsData;
            error: GetProjectsProjectIdDeploymentsError;
        };
    };
    getProjectsProjectIdDeploymentsDeploymentId: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters): ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters, TPageParam, GetProjectsProjectIdDeploymentsDeploymentIdError>): Promise<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters, TPageParam, GetProjectsProjectIdDeploymentsDeploymentIdError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters, TPageParam, GetProjectsProjectIdDeploymentsDeploymentIdError>): Promise<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): Promise<GetProjectsProjectIdDeploymentsDeploymentIdData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): Promise<GetProjectsProjectIdDeploymentsDeploymentIdData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters)): OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>,
            data: GetProjectsProjectIdDeploymentsDeploymentIdData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters)): GetProjectsProjectIdDeploymentsDeploymentIdData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters)): QueryState<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, GetProjectsProjectIdDeploymentsDeploymentIdError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdDeploymentsDeploymentIdParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdDeploymentsDeploymentIdSchema, options: {
            parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>): Promise<RequestFnResponse<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>, updater: Updater<NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdData> | undefined, NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdDeploymentsDeploymentIdData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdDeploymentsDeploymentIdParameters) | ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, updater: Updater<NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdData> | undefined, NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdDeploymentsDeploymentIdData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdParameters, TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdParameters, TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdTotal = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdByParametersTotal = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             deploymentId: deploymentId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdResults = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 deploymentId: deploymentId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 deploymentId: deploymentId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDeploymentsDeploymentIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdCombinedResults = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 deploymentId: deploymentId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 deploymentId: deploymentId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDeploymentsDeploymentIdCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters): ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentId.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdParameters, TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, GetProjectsProjectIdDeploymentsDeploymentIdData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdParameters>, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters, GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdData, GetProjectsProjectIdDeploymentsDeploymentIdError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdSchema, GetProjectsProjectIdDeploymentsDeploymentIdParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdError | Error>;
        schema: GetProjectsProjectIdDeploymentsDeploymentIdSchema;
        types: {
            parameters: GetProjectsProjectIdDeploymentsDeploymentIdParameters;
            data: GetProjectsProjectIdDeploymentsDeploymentIdData;
            error: GetProjectsProjectIdDeploymentsDeploymentIdError;
        };
    };
    getProjectsProjectIdDeploymentsDeploymentIdLogs: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters): ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TPageParam, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): Promise<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TPageParam, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TPageParam, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): Promise<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): Promise<GetProjectsProjectIdDeploymentsDeploymentIdLogsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): Promise<GetProjectsProjectIdDeploymentsDeploymentIdLogsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters)): OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>,
            data: GetProjectsProjectIdDeploymentsDeploymentIdLogsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters)): GetProjectsProjectIdDeploymentsDeploymentIdLogsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters)): QueryState<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, options: {
            parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>): Promise<RequestFnResponse<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>, updater: Updater<NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdLogsData> | undefined, NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdLogsData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdDeploymentsDeploymentIdLogsData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters) | ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, updater: Updater<NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdLogsData> | undefined, NoInfer<GetProjectsProjectIdDeploymentsDeploymentIdLogsData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdDeploymentsDeploymentIdLogsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdLogsTotal = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdLogsByParametersTotal = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             deploymentId: deploymentId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, TInfinite, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdLogsResults = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 deploymentId: deploymentId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 deploymentId: deploymentId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDeploymentsDeploymentIdLogsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdDeploymentsDeploymentIdLogsCombinedResults = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 deploymentId: deploymentId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 deploymentId: deploymentId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDeploymentsDeploymentIdLogsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters): ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDeploymentsDeploymentIdLogs.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         deploymentId: deploymentId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters, GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdDeploymentsDeploymentIdLogsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters> | (GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdDeploymentsDeploymentIdLogsData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema, GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdDeploymentsDeploymentIdLogsError | Error>;
        schema: GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema;
        types: {
            parameters: GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters;
            data: GetProjectsProjectIdDeploymentsDeploymentIdLogsData;
            error: GetProjectsProjectIdDeploymentsDeploymentIdLogsError;
        };
    };
    getProjectsProjectIdEnvironment: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdEnvironmentParameters): ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdEnvironmentError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdEnvironmentParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters, TPageParam, GetProjectsProjectIdEnvironmentError>): Promise<OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdEnvironmentParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters, TPageParam, GetProjectsProjectIdEnvironmentError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdEnvironmentParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters, TPageParam, GetProjectsProjectIdEnvironmentError>): Promise<OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): Promise<GetProjectsProjectIdEnvironmentData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): Promise<GetProjectsProjectIdEnvironmentData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters)): OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>,
            data: GetProjectsProjectIdEnvironmentData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters)): GetProjectsProjectIdEnvironmentData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters)): QueryState<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdEnvironmentParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters>, GetProjectsProjectIdEnvironmentError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdEnvironmentParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdEnvironmentSchema, options: {
            parameters: GetProjectsProjectIdEnvironmentParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>): Promise<RequestFnResponse<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdEnvironmentParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>, updater: Updater<NoInfer<GetProjectsProjectIdEnvironmentData> | undefined, NoInfer<GetProjectsProjectIdEnvironmentData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdEnvironmentData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdEnvironmentParameters) | ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>, updater: Updater<NoInfer<GetProjectsProjectIdEnvironmentData> | undefined, NoInfer<GetProjectsProjectIdEnvironmentData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdEnvironmentData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdEnvironmentParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdEnvironment.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             branch: initialBranch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdEnvironmentParameters, TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, OperationInfiniteData<TData, GetProjectsProjectIdEnvironmentParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdEnvironmentData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdEnvironmentParameters>, GetProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdEnvironment.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             branch: initialBranch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdEnvironmentParameters, TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, OperationInfiniteData<TData, GetProjectsProjectIdEnvironmentParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdEnvironmentData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdEnvironmentParameters>, GetProjectsProjectIdEnvironmentError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdEnvironmentTotal = qraft.v1Service.getProjectsProjectIdEnvironment.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdEnvironmentByParametersTotal = qraft.v1Service.getProjectsProjectIdEnvironment.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         },
         *         query: {
         *             branch: branch
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError> | QueryFiltersByQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentData, TInfinite, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdEnvironmentResults = qraft.v1Service.getProjectsProjectIdEnvironment.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             },
         *             query: {
         *                 branch: branch1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             },
         *             query: {
         *                 branch: branch2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdEnvironmentResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdEnvironmentCombinedResults = qraft.v1Service.getProjectsProjectIdEnvironment.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             },
         *             query: {
         *                 branch: branch1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             },
         *             query: {
         *                 branch: branch2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdEnvironmentCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdEnvironmentParameters): ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdEnvironment.useQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdEnvironmentError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdEnvironment.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             branch: initialBranch
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdEnvironmentParameters, TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, OperationInfiniteData<TData, GetProjectsProjectIdEnvironmentParameters>, GetProjectsProjectIdEnvironmentData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdEnvironmentData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdEnvironmentParameters>, GetProjectsProjectIdEnvironmentError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters, GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdEnvironmentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters> | (GetProjectsProjectIdEnvironmentParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdEnvironmentData, GetProjectsProjectIdEnvironmentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdEnvironmentSchema, GetProjectsProjectIdEnvironmentParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdEnvironmentError | Error>;
        schema: GetProjectsProjectIdEnvironmentSchema;
        types: {
            parameters: GetProjectsProjectIdEnvironmentParameters;
            data: GetProjectsProjectIdEnvironmentData;
            error: GetProjectsProjectIdEnvironmentError;
        };
    };
    putProjectsProjectIdEnvironment: {
        /**/
        getMutationKey(parameters: PutProjectsProjectIdEnvironmentParameters | void): ServiceOperationMutationKey<PutProjectsProjectIdEnvironmentSchema, PutProjectsProjectIdEnvironmentParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironment.useMutation({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironment.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PutProjectsProjectIdEnvironmentBody, TContext = unknown>(parameters: PutProjectsProjectIdEnvironmentParameters, options?: ServiceOperationUseMutationOptions<PutProjectsProjectIdEnvironmentSchema, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, TVariables, PutProjectsProjectIdEnvironmentError, TContext>): UseMutationResult<PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironment.useMutation({
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironment.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     },
         *     query: {
         *         branch: branch
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutProjectsProjectIdEnvironmentSchema, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, TVariables, PutProjectsProjectIdEnvironmentError, TContext>): UseMutationResult<PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putProjectsProjectIdEnvironmentTotal = qraft.v1Service.putProjectsProjectIdEnvironment.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putProjectsProjectIdEnvironmentTotal = qraft.v1Service.putProjectsProjectIdEnvironment.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         },
         *         query: {
         *             branch: branch
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, PutProjectsProjectIdEnvironmentError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdEnvironmentSchema, PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, PutProjectsProjectIdEnvironmentError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, PutProjectsProjectIdEnvironmentError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdEnvironmentSchema, PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, PutProjectsProjectIdEnvironmentError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentParameters>, client?: (schema: PutProjectsProjectIdEnvironmentSchema, options: ServiceOperationMutationFnOptions<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentParameters>) => Promise<RequestFnResponse<PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentError>>): Promise<RequestFnResponse<PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putProjectsProjectIdEnvironmentPendingMutationVariables = qraft.v1Service.putProjectsProjectIdEnvironment.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putProjectsProjectIdEnvironmentMutationData = qraft.v1Service.putProjectsProjectIdEnvironment.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             },
         *             query: {
         *                 branch: branch
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentError, MutationVariables<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, PutProjectsProjectIdEnvironmentError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdEnvironmentSchema, PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentParameters, PutProjectsProjectIdEnvironmentError, TContext>;
            select?: (mutation: Mutation<PutProjectsProjectIdEnvironmentData, PutProjectsProjectIdEnvironmentError, MutationVariables<PutProjectsProjectIdEnvironmentBody, PutProjectsProjectIdEnvironmentParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutProjectsProjectIdEnvironmentSchema;
        types: {
            parameters: PutProjectsProjectIdEnvironmentParameters;
            data: PutProjectsProjectIdEnvironmentData;
            error: PutProjectsProjectIdEnvironmentError;
            body: PutProjectsProjectIdEnvironmentBody;
        };
    };
    putProjectsProjectIdEnvironmentChangeAutoDeploy: {
        /**/
        getMutationKey(parameters: PutProjectsProjectIdEnvironmentChangeAutoDeployParameters | void): ServiceOperationMutationKey<PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PutProjectsProjectIdEnvironmentChangeAutoDeployBody, TContext = unknown>(parameters: PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, options?: ServiceOperationUseMutationOptions<PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, TVariables, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext>): UseMutationResult<PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, TVariables, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext>): UseMutationResult<PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putProjectsProjectIdEnvironmentChangeAutoDeployTotal = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putProjectsProjectIdEnvironmentChangeAutoDeployTotal = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters>, client?: (schema: PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, options: ServiceOperationMutationFnOptions<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters>) => Promise<RequestFnResponse<PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployError>>): Promise<RequestFnResponse<PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putProjectsProjectIdEnvironmentChangeAutoDeployPendingMutationVariables = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putProjectsProjectIdEnvironmentChangeAutoDeployMutationData = qraft.v1Service.putProjectsProjectIdEnvironmentChangeAutoDeploy.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployError, MutationVariables<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdEnvironmentChangeAutoDeploySchema, PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters, PutProjectsProjectIdEnvironmentChangeAutoDeployError, TContext>;
            select?: (mutation: Mutation<PutProjectsProjectIdEnvironmentChangeAutoDeployData, PutProjectsProjectIdEnvironmentChangeAutoDeployError, MutationVariables<PutProjectsProjectIdEnvironmentChangeAutoDeployBody, PutProjectsProjectIdEnvironmentChangeAutoDeployParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutProjectsProjectIdEnvironmentChangeAutoDeploySchema;
        types: {
            parameters: PutProjectsProjectIdEnvironmentChangeAutoDeployParameters;
            data: PutProjectsProjectIdEnvironmentChangeAutoDeployData;
            error: PutProjectsProjectIdEnvironmentChangeAutoDeployError;
            body: PutProjectsProjectIdEnvironmentChangeAutoDeployBody;
        };
    };
    getProjectsProjectIdDomains: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDomainsParameters): ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDomainsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters, TPageParam, GetProjectsProjectIdDomainsError>): Promise<OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters, TPageParam, GetProjectsProjectIdDomainsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdDomainsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters, TPageParam, GetProjectsProjectIdDomainsError>): Promise<OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): Promise<GetProjectsProjectIdDomainsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): Promise<GetProjectsProjectIdDomainsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters)): OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>,
            data: GetProjectsProjectIdDomainsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters)): GetProjectsProjectIdDomainsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters)): QueryState<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdDomainsParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters>, GetProjectsProjectIdDomainsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdDomainsParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdDomainsSchema, options: {
            parameters: GetProjectsProjectIdDomainsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>): Promise<RequestFnResponse<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdDomainsParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>, updater: Updater<NoInfer<GetProjectsProjectIdDomainsData> | undefined, NoInfer<GetProjectsProjectIdDomainsData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdDomainsData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdDomainsParameters) | ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>, updater: Updater<NoInfer<GetProjectsProjectIdDomainsData> | undefined, NoInfer<GetProjectsProjectIdDomainsData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdDomainsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdDomainsParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomains.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsParameters, TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsParameters>, GetProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomains.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsParameters, TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsParameters>, GetProjectsProjectIdDomainsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdDomainsTotal = qraft.v1Service.getProjectsProjectIdDomains.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdDomainsByParametersTotal = qraft.v1Service.getProjectsProjectIdDomains.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsData, TInfinite, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdDomainsResults = qraft.v1Service.getProjectsProjectIdDomains.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDomainsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdDomainsCombinedResults = qraft.v1Service.getProjectsProjectIdDomains.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDomainsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDomainsParameters): ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomains.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDomainsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomains.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsParameters, TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsParameters>, GetProjectsProjectIdDomainsData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsParameters>, GetProjectsProjectIdDomainsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters, GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdDomainsData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters> | (GetProjectsProjectIdDomainsParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdDomainsData, GetProjectsProjectIdDomainsError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsSchema, GetProjectsProjectIdDomainsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdDomainsError | Error>;
        schema: GetProjectsProjectIdDomainsSchema;
        types: {
            parameters: GetProjectsProjectIdDomainsParameters;
            data: GetProjectsProjectIdDomainsData;
            error: GetProjectsProjectIdDomainsError;
        };
    };
    postProjectsProjectIdDomains: {
        /**/
        getMutationKey(parameters: PostProjectsProjectIdDomainsParameters | void): ServiceOperationMutationKey<PostProjectsProjectIdDomainsSchema, PostProjectsProjectIdDomainsParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomains.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomains.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostProjectsProjectIdDomainsBody, TContext = unknown>(parameters: PostProjectsProjectIdDomainsParameters, options?: ServiceOperationUseMutationOptions<PostProjectsProjectIdDomainsSchema, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, TVariables, PostProjectsProjectIdDomainsError, TContext>): UseMutationResult<PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomains.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomains.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostProjectsProjectIdDomainsSchema, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, TVariables, PostProjectsProjectIdDomainsError, TContext>): UseMutationResult<PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postProjectsProjectIdDomainsTotal = qraft.v1Service.postProjectsProjectIdDomains.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postProjectsProjectIdDomainsTotal = qraft.v1Service.postProjectsProjectIdDomains.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, PostProjectsProjectIdDomainsError, TContext> | MutationFiltersByMutationKey<PostProjectsProjectIdDomainsSchema, PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, PostProjectsProjectIdDomainsError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, PostProjectsProjectIdDomainsError, TContext> | MutationFiltersByMutationKey<PostProjectsProjectIdDomainsSchema, PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, PostProjectsProjectIdDomainsError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsParameters>, client?: (schema: PostProjectsProjectIdDomainsSchema, options: ServiceOperationMutationFnOptions<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsParameters>) => Promise<RequestFnResponse<PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsError>>): Promise<RequestFnResponse<PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postProjectsProjectIdDomainsPendingMutationVariables = qraft.v1Service.postProjectsProjectIdDomains.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postProjectsProjectIdDomainsMutationData = qraft.v1Service.postProjectsProjectIdDomains.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsError, MutationVariables<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, PostProjectsProjectIdDomainsError, TContext> | MutationFiltersByMutationKey<PostProjectsProjectIdDomainsSchema, PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsParameters, PostProjectsProjectIdDomainsError, TContext>;
            select?: (mutation: Mutation<PostProjectsProjectIdDomainsData, PostProjectsProjectIdDomainsError, MutationVariables<PostProjectsProjectIdDomainsBody, PostProjectsProjectIdDomainsParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostProjectsProjectIdDomainsSchema;
        types: {
            parameters: PostProjectsProjectIdDomainsParameters;
            data: PostProjectsProjectIdDomainsData;
            error: PostProjectsProjectIdDomainsError;
            body: PostProjectsProjectIdDomainsBody;
        };
    };
    deleteProjectsProjectIdDomainsDomainId: {
        /**/
        getMutationKey(parameters: DeleteProjectsProjectIdDomainsDomainIdParameters | void): ServiceOperationMutationKey<DeleteProjectsProjectIdDomainsDomainIdSchema, DeleteProjectsProjectIdDomainsDomainIdParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useMutation({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteProjectsProjectIdDomainsDomainIdBody, TContext = unknown>(parameters: DeleteProjectsProjectIdDomainsDomainIdParameters, options?: ServiceOperationUseMutationOptions<DeleteProjectsProjectIdDomainsDomainIdSchema, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, TVariables, DeleteProjectsProjectIdDomainsDomainIdError, TContext>): UseMutationResult<DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useMutation({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteProjectsProjectIdDomainsDomainIdSchema, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, TVariables, DeleteProjectsProjectIdDomainsDomainIdError, TContext>): UseMutationResult<DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteProjectsProjectIdDomainsDomainIdTotal = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteProjectsProjectIdDomainsDomainIdTotal = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             domainId: domainId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, DeleteProjectsProjectIdDomainsDomainIdError, TContext> | MutationFiltersByMutationKey<DeleteProjectsProjectIdDomainsDomainIdSchema, DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, DeleteProjectsProjectIdDomainsDomainIdError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, DeleteProjectsProjectIdDomainsDomainIdError, TContext> | MutationFiltersByMutationKey<DeleteProjectsProjectIdDomainsDomainIdSchema, DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, DeleteProjectsProjectIdDomainsDomainIdError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdParameters>, client?: (schema: DeleteProjectsProjectIdDomainsDomainIdSchema, options: ServiceOperationMutationFnOptions<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdParameters>) => Promise<RequestFnResponse<DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdError>>): Promise<RequestFnResponse<DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteProjectsProjectIdDomainsDomainIdPendingMutationVariables = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteProjectsProjectIdDomainsDomainIdMutationData = qraft.v1Service.deleteProjectsProjectIdDomainsDomainId.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId,
         *                 domainId: domainId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdError, MutationVariables<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, DeleteProjectsProjectIdDomainsDomainIdError, TContext> | MutationFiltersByMutationKey<DeleteProjectsProjectIdDomainsDomainIdSchema, DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdParameters, DeleteProjectsProjectIdDomainsDomainIdError, TContext>;
            select?: (mutation: Mutation<DeleteProjectsProjectIdDomainsDomainIdData, DeleteProjectsProjectIdDomainsDomainIdError, MutationVariables<DeleteProjectsProjectIdDomainsDomainIdBody, DeleteProjectsProjectIdDomainsDomainIdParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteProjectsProjectIdDomainsDomainIdSchema;
        types: {
            parameters: DeleteProjectsProjectIdDomainsDomainIdParameters;
            data: DeleteProjectsProjectIdDomainsDomainIdData;
            error: DeleteProjectsProjectIdDomainsDomainIdError;
            body: DeleteProjectsProjectIdDomainsDomainIdBody;
        };
    };
    getProjectsProjectIdDomainsDomainIdVerify: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters): ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdVerifyParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters, TPageParam, GetProjectsProjectIdDomainsDomainIdVerifyError>): Promise<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdVerifyParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters, TPageParam, GetProjectsProjectIdDomainsDomainIdVerifyError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdDomainsDomainIdVerifyParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters, TPageParam, GetProjectsProjectIdDomainsDomainIdVerifyError>): Promise<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): Promise<GetProjectsProjectIdDomainsDomainIdVerifyData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): Promise<GetProjectsProjectIdDomainsDomainIdVerifyData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters)): OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>,
            data: GetProjectsProjectIdDomainsDomainIdVerifyData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters)): GetProjectsProjectIdDomainsDomainIdVerifyData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters)): QueryState<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, GetProjectsProjectIdDomainsDomainIdVerifyError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdDomainsDomainIdVerifyParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdDomainsDomainIdVerifySchema, options: {
            parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>): Promise<RequestFnResponse<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>, updater: Updater<NoInfer<GetProjectsProjectIdDomainsDomainIdVerifyData> | undefined, NoInfer<GetProjectsProjectIdDomainsDomainIdVerifyData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdDomainsDomainIdVerifyData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdDomainsDomainIdVerifyParameters) | ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, updater: Updater<NoInfer<GetProjectsProjectIdDomainsDomainIdVerifyData> | undefined, NoInfer<GetProjectsProjectIdDomainsDomainIdVerifyData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdDomainsDomainIdVerifyData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdVerifyParameters, TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdVerifyParameters, TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdVerifyTotal = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdVerifyByParametersTotal = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             domainId: domainId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyData, TInfinite, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdVerifyResults = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 domainId: domainId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 domainId: domainId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDomainsDomainIdVerifyResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdVerifyCombinedResults = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 domainId: domainId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 domainId: domainId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDomainsDomainIdVerifyCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters): ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdVerify.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdVerifyParameters, TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, GetProjectsProjectIdDomainsDomainIdVerifyData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdVerifyParameters>, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters, GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdDomainsDomainIdVerifyData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters> | (GetProjectsProjectIdDomainsDomainIdVerifyParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdDomainsDomainIdVerifyData, GetProjectsProjectIdDomainsDomainIdVerifyError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdVerifySchema, GetProjectsProjectIdDomainsDomainIdVerifyParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdVerifyError | Error>;
        schema: GetProjectsProjectIdDomainsDomainIdVerifySchema;
        types: {
            parameters: GetProjectsProjectIdDomainsDomainIdVerifyParameters;
            data: GetProjectsProjectIdDomainsDomainIdVerifyData;
            error: GetProjectsProjectIdDomainsDomainIdVerifyError;
        };
    };
    postProjectsProjectIdDomainsDomainIdSetPrimary: {
        /**/
        getMutationKey(parameters: PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters | void): ServiceOperationMutationKey<PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useMutation({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, TContext = unknown>(parameters: PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, options?: ServiceOperationUseMutationOptions<PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, TVariables, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext>): UseMutationResult<PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useMutation({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, TVariables, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext>): UseMutationResult<PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postProjectsProjectIdDomainsDomainIdSetPrimaryTotal = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postProjectsProjectIdDomainsDomainIdSetPrimaryTotal = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             domainId: domainId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext> | MutationFiltersByMutationKey<PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext> | MutationFiltersByMutationKey<PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters>, client?: (schema: PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, options: ServiceOperationMutationFnOptions<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters>) => Promise<RequestFnResponse<PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryError>>): Promise<RequestFnResponse<PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postProjectsProjectIdDomainsDomainIdSetPrimaryPendingMutationVariables = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postProjectsProjectIdDomainsDomainIdSetPrimaryMutationData = qraft.v1Service.postProjectsProjectIdDomainsDomainIdSetPrimary.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId,
         *                 domainId: domainId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, MutationVariables<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext> | MutationFiltersByMutationKey<PostProjectsProjectIdDomainsDomainIdSetPrimarySchema, PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, TContext>;
            select?: (mutation: Mutation<PostProjectsProjectIdDomainsDomainIdSetPrimaryData, PostProjectsProjectIdDomainsDomainIdSetPrimaryError, MutationVariables<PostProjectsProjectIdDomainsDomainIdSetPrimaryBody, PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostProjectsProjectIdDomainsDomainIdSetPrimarySchema;
        types: {
            parameters: PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters;
            data: PostProjectsProjectIdDomainsDomainIdSetPrimaryData;
            error: PostProjectsProjectIdDomainsDomainIdSetPrimaryError;
            body: PostProjectsProjectIdDomainsDomainIdSetPrimaryBody;
        };
    };
    getProjectsProjectIdDomainsDomainIdParent: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDomainsDomainIdParentParameters): ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdParentParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters, TPageParam, GetProjectsProjectIdDomainsDomainIdParentError>): Promise<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdParentParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters, TPageParam, GetProjectsProjectIdDomainsDomainIdParentError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdDomainsDomainIdParentParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters, TPageParam, GetProjectsProjectIdDomainsDomainIdParentError>): Promise<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): Promise<GetProjectsProjectIdDomainsDomainIdParentData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): Promise<GetProjectsProjectIdDomainsDomainIdParentData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters)): OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>,
            data: GetProjectsProjectIdDomainsDomainIdParentData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters)): GetProjectsProjectIdDomainsDomainIdParentData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters)): QueryState<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdDomainsDomainIdParentParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters>, GetProjectsProjectIdDomainsDomainIdParentError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdDomainsDomainIdParentParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdDomainsDomainIdParentSchema, options: {
            parameters: GetProjectsProjectIdDomainsDomainIdParentParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>): Promise<RequestFnResponse<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdDomainsDomainIdParentParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>, updater: Updater<NoInfer<GetProjectsProjectIdDomainsDomainIdParentData> | undefined, NoInfer<GetProjectsProjectIdDomainsDomainIdParentData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdDomainsDomainIdParentData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdDomainsDomainIdParentParameters) | ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>, updater: Updater<NoInfer<GetProjectsProjectIdDomainsDomainIdParentData> | undefined, NoInfer<GetProjectsProjectIdDomainsDomainIdParentData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdDomainsDomainIdParentData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdDomainsDomainIdParentParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdParentParameters, TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdParentParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsDomainIdParentData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdParentParameters>, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdParentParameters, TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdParentParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsDomainIdParentData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdParentParameters>, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdParentTotal = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdParentByParametersTotal = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId,
         *             domainId: domainId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError> | QueryFiltersByQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentData, TInfinite, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdParentResults = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 domainId: domainId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 domainId: domainId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDomainsDomainIdParentResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdDomainsDomainIdParentCombinedResults = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1,
         *                 domainId: domainId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2,
         *                 domainId: domainId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdDomainsDomainIdParentCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdDomainsDomainIdParentParameters): ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdDomainsDomainIdParent.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId,
         *         domainId: domainId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdDomainsDomainIdParentParameters, TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdParentParameters>, GetProjectsProjectIdDomainsDomainIdParentData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdDomainsDomainIdParentData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdDomainsDomainIdParentParameters>, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters, GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdDomainsDomainIdParentData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters> | (GetProjectsProjectIdDomainsDomainIdParentParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdDomainsDomainIdParentData, GetProjectsProjectIdDomainsDomainIdParentError, TData, ServiceOperationQueryKey<GetProjectsProjectIdDomainsDomainIdParentSchema, GetProjectsProjectIdDomainsDomainIdParentParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdDomainsDomainIdParentError | Error>;
        schema: GetProjectsProjectIdDomainsDomainIdParentSchema;
        types: {
            parameters: GetProjectsProjectIdDomainsDomainIdParentParameters;
            data: GetProjectsProjectIdDomainsDomainIdParentData;
            error: GetProjectsProjectIdDomainsDomainIdParentError;
        };
    };
    getProjectsProjectIdServices: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdServicesParameters): ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdServices.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, TData, ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdServicesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdServices.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, TData, ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdServicesError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetProjectsProjectIdServicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters, TPageParam, GetProjectsProjectIdServicesError>): Promise<OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetProjectsProjectIdServicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters, TPageParam, GetProjectsProjectIdServicesError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetProjectsProjectIdServicesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters, TPageParam, GetProjectsProjectIdServicesError>): Promise<OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): Promise<GetProjectsProjectIdServicesData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): Promise<GetProjectsProjectIdServicesData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters)): OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>,
            data: NoInfer<OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>,
            data: GetProjectsProjectIdServicesData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters)): GetProjectsProjectIdServicesData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters)): QueryState<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetProjectsProjectIdServicesParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>): QueryState<OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters>, GetProjectsProjectIdServicesError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetProjectsProjectIdServicesParameters, TMeta, TSignal>), client?: (schema: GetProjectsProjectIdServicesSchema, options: {
            parameters: GetProjectsProjectIdServicesParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>): Promise<RequestFnResponse<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetProjectsProjectIdServicesParameters | ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters>> | undefined, NoInfer<OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>, updater: Updater<NoInfer<GetProjectsProjectIdServicesData> | undefined, NoInfer<GetProjectsProjectIdServicesData> | undefined>, options?: SetDataOptions): Array<GetProjectsProjectIdServicesData | undefined>;
        /**/
        setQueryData(parameters: (GetProjectsProjectIdServicesParameters) | ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>, updater: Updater<NoInfer<GetProjectsProjectIdServicesData> | undefined, NoInfer<GetProjectsProjectIdServicesData> | undefined>, options?: SetDataOptions): GetProjectsProjectIdServicesData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetProjectsProjectIdServicesParameters): ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdServices.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdServicesParameters, TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, OperationInfiniteData<TData, GetProjectsProjectIdServicesParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdServicesData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdServicesParameters>, GetProjectsProjectIdServicesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdServices.useInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetProjectsProjectIdServicesParameters, TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, OperationInfiniteData<TData, GetProjectsProjectIdServicesParameters>, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdServicesData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdServicesParameters>, GetProjectsProjectIdServicesError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getProjectsProjectIdServicesTotal = qraft.v1Service.getProjectsProjectIdServices.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getProjectsProjectIdServicesByParametersTotal = qraft.v1Service.getProjectsProjectIdServices.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError> | QueryFiltersByQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesData, TInfinite, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getProjectsProjectIdServicesResults = qraft.v1Service.getProjectsProjectIdServices.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdServicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getProjectsProjectIdServicesCombinedResults = qraft.v1Service.getProjectsProjectIdServices.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 projectId: projectId1
         *             }
         *         },
         *         {
         *             path: {
         *                 projectId: projectId2
         *             }
         *         }
         *     ]
         * });
         * getProjectsProjectIdServicesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>, TCombinedResult = Array<UseQueryResult<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetProjectsProjectIdServicesParameters): ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdServices.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options?: Omit<UndefinedInitialDataOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, TData, ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>>, "queryKey">): UseQueryResult<TData, GetProjectsProjectIdServicesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getProjectsProjectIdServices.useQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * ```
         */
        useQuery<TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options: Omit<DefinedInitialDataOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, TData, ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetProjectsProjectIdServicesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProjectsProjectIdServices.useSuspenseInfiniteQuery({
         *     path: {
         *         projectId: projectId
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetProjectsProjectIdServicesParameters, TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, OperationInfiniteData<TData, GetProjectsProjectIdServicesParameters>, GetProjectsProjectIdServicesData, ServiceOperationInfiniteQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetProjectsProjectIdServicesData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProjectsProjectIdServicesParameters>, GetProjectsProjectIdServicesError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters, GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetProjectsProjectIdServicesData>(parameters: ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters> | (GetProjectsProjectIdServicesParameters), options?: Omit<UseSuspenseQueryOptions<GetProjectsProjectIdServicesData, GetProjectsProjectIdServicesError, TData, ServiceOperationQueryKey<GetProjectsProjectIdServicesSchema, GetProjectsProjectIdServicesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetProjectsProjectIdServicesError | Error>;
        schema: GetProjectsProjectIdServicesSchema;
        types: {
            parameters: GetProjectsProjectIdServicesParameters;
            data: GetProjectsProjectIdServicesData;
            error: GetProjectsProjectIdServicesError;
        };
    };
    putProjectsProjectIdServices: {
        /**/
        getMutationKey(parameters: PutProjectsProjectIdServicesParameters | void): ServiceOperationMutationKey<PutProjectsProjectIdServicesSchema, PutProjectsProjectIdServicesParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdServices.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdServices.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PutProjectsProjectIdServicesBody, TContext = unknown>(parameters: PutProjectsProjectIdServicesParameters, options?: ServiceOperationUseMutationOptions<PutProjectsProjectIdServicesSchema, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, TVariables, PutProjectsProjectIdServicesError, TContext>): UseMutationResult<PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdServices.useMutation({
         *     path: {
         *         projectId: projectId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putProjectsProjectIdServices.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         projectId: projectId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutProjectsProjectIdServicesSchema, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, TVariables, PutProjectsProjectIdServicesError, TContext>): UseMutationResult<PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putProjectsProjectIdServicesTotal = qraft.v1Service.putProjectsProjectIdServices.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putProjectsProjectIdServicesTotal = qraft.v1Service.putProjectsProjectIdServices.useIsMutating({
         *     parameters: {
         *         path: {
         *             projectId: projectId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, PutProjectsProjectIdServicesError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdServicesSchema, PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, PutProjectsProjectIdServicesError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, PutProjectsProjectIdServicesError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdServicesSchema, PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, PutProjectsProjectIdServicesError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesParameters>, client?: (schema: PutProjectsProjectIdServicesSchema, options: ServiceOperationMutationFnOptions<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesParameters>) => Promise<RequestFnResponse<PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesError>>): Promise<RequestFnResponse<PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putProjectsProjectIdServicesPendingMutationVariables = qraft.v1Service.putProjectsProjectIdServices.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putProjectsProjectIdServicesMutationData = qraft.v1Service.putProjectsProjectIdServices.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 projectId: projectId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesError, MutationVariables<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, PutProjectsProjectIdServicesError, TContext> | MutationFiltersByMutationKey<PutProjectsProjectIdServicesSchema, PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesParameters, PutProjectsProjectIdServicesError, TContext>;
            select?: (mutation: Mutation<PutProjectsProjectIdServicesData, PutProjectsProjectIdServicesError, MutationVariables<PutProjectsProjectIdServicesBody, PutProjectsProjectIdServicesParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutProjectsProjectIdServicesSchema;
        types: {
            parameters: PutProjectsProjectIdServicesParameters;
            data: PutProjectsProjectIdServicesData;
            error: PutProjectsProjectIdServicesError;
            body: PutProjectsProjectIdServicesBody;
        };
    };
    postServers: {
        /**/
        getMutationKey(parameters: PostServersParameters | void): ServiceOperationMutationKey<PostServersSchema, PostServersParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostServersBody, TContext = unknown>(parameters: PostServersParameters, options?: ServiceOperationUseMutationOptions<PostServersSchema, PostServersData, PostServersParameters, TVariables, PostServersError, TContext>): UseMutationResult<PostServersData, PostServersError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostServersBody, PostServersParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostServersSchema, PostServersData, PostServersParameters, TVariables, PostServersError, TContext>): UseMutationResult<PostServersData, PostServersError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postServersTotal = qraft.v1Service.postServers.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postServersTotal = qraft.v1Service.postServers.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext> | MutationFiltersByMutationKey<PostServersSchema, PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext> | MutationFiltersByMutationKey<PostServersSchema, PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostServersBody, PostServersParameters>, client?: (schema: PostServersSchema, options: ServiceOperationMutationFnOptions<PostServersBody, PostServersParameters>) => Promise<RequestFnResponse<PostServersData, PostServersError>>): Promise<RequestFnResponse<PostServersData, PostServersError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postServersPendingMutationVariables = qraft.v1Service.postServers.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postServersMutationData = qraft.v1Service.postServers.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostServersData, PostServersError, MutationVariables<PostServersBody, PostServersParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext> | MutationFiltersByMutationKey<PostServersSchema, PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext>;
            select?: (mutation: Mutation<PostServersData, PostServersError, MutationVariables<PostServersBody, PostServersParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostServersSchema;
        types: {
            parameters: PostServersParameters;
            data: PostServersData;
            error: PostServersError;
            body: PostServersBody;
        };
    };
    putServers: {
        /**/
        getMutationKey(parameters: PutServersParameters | void): ServiceOperationMutationKey<PutServersSchema, PutServersParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PutServersBody, TContext = unknown>(parameters: PutServersParameters, options?: ServiceOperationUseMutationOptions<PutServersSchema, PutServersData, PutServersParameters, TVariables, PutServersError, TContext>): UseMutationResult<PutServersData, PutServersError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutServersBody, PutServersParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutServersSchema, PutServersData, PutServersParameters, TVariables, PutServersError, TContext>): UseMutationResult<PutServersData, PutServersError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putServersTotal = qraft.v1Service.putServers.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putServersTotal = qraft.v1Service.putServers.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext> | MutationFiltersByMutationKey<PutServersSchema, PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext> | MutationFiltersByMutationKey<PutServersSchema, PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutServersBody, PutServersParameters>, client?: (schema: PutServersSchema, options: ServiceOperationMutationFnOptions<PutServersBody, PutServersParameters>) => Promise<RequestFnResponse<PutServersData, PutServersError>>): Promise<RequestFnResponse<PutServersData, PutServersError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putServersPendingMutationVariables = qraft.v1Service.putServers.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putServersMutationData = qraft.v1Service.putServers.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutServersData, PutServersError, MutationVariables<PutServersBody, PutServersParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext> | MutationFiltersByMutationKey<PutServersSchema, PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext>;
            select?: (mutation: Mutation<PutServersData, PutServersError, MutationVariables<PutServersBody, PutServersParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutServersSchema;
        types: {
            parameters: PutServersParameters;
            data: PutServersData;
            error: PutServersError;
            body: PutServersBody;
        };
    };
    getServersTiers: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetServersTiersParameters | void): ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getServersTiers.useQuery()
         * ```
         */
        useQuery<TData = GetServersTiersData>(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options?: Omit<UndefinedInitialDataOptions<GetServersTiersData, GetServersTiersError, TData, ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>>, "queryKey">): UseQueryResult<TData, GetServersTiersError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getServersTiers.useQuery()
         * ```
         */
        useQuery<TData = GetServersTiersData>(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options: Omit<DefinedInitialDataOptions<GetServersTiersData, GetServersTiersError, TData, ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetServersTiersError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetServersTiersParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetServersTiersSchema, GetServersTiersData, GetServersTiersParameters, TPageParam, GetServersTiersError>): Promise<OperationInfiniteData<GetServersTiersData, GetServersTiersParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetServersTiersParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetServersTiersSchema, GetServersTiersData, GetServersTiersParameters, TPageParam, GetServersTiersError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetServersTiersParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetServersTiersSchema, GetServersTiersData, GetServersTiersParameters, TPageParam, GetServersTiersError>): Promise<OperationInfiniteData<GetServersTiersData, GetServersTiersParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetServersTiersSchema, GetServersTiersData, GetServersTiersParameters, GetServersTiersError> | void): Promise<GetServersTiersData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetServersTiersSchema, GetServersTiersData, GetServersTiersParameters, GetServersTiersError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetServersTiersSchema, GetServersTiersData, GetServersTiersParameters, GetServersTiersError> | void): Promise<GetServersTiersData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void)): OperationInfiniteData<GetServersTiersData, GetServersTiersParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters>,
            data: NoInfer<OperationInfiniteData<GetServersTiersData, GetServersTiersParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>,
            data: GetServersTiersData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void)): GetServersTiersData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void)): QueryState<GetServersTiersData, GetServersTiersError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetServersTiersParameters | ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters> | void): QueryState<OperationInfiniteData<GetServersTiersData, GetServersTiersParameters>, GetServersTiersError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetServersTiersSchema, GetServersTiersParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetServersTiersParameters, TMeta, TSignal> | void), client?: (schema: GetServersTiersSchema, options: {
            parameters: GetServersTiersParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetServersTiersData, GetServersTiersError>>): Promise<RequestFnResponse<GetServersTiersData, GetServersTiersError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetServersTiersParameters | ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetServersTiersData, GetServersTiersParameters>> | undefined, NoInfer<OperationInfiniteData<GetServersTiersData, GetServersTiersParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetServersTiersData, GetServersTiersParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>, updater: Updater<NoInfer<GetServersTiersData> | undefined, NoInfer<GetServersTiersData> | undefined>, options?: SetDataOptions): Array<GetServersTiersData | undefined>;
        /**/
        setQueryData(parameters: (GetServersTiersParameters | undefined) | ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>, updater: Updater<NoInfer<GetServersTiersData> | undefined, NoInfer<GetServersTiersData> | undefined>, options?: SetDataOptions): GetServersTiersData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetServersTiersParameters | void): ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getServersTiers.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetServersTiersParameters, TData = GetServersTiersData>(parameters: ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetServersTiersData, GetServersTiersError, OperationInfiniteData<TData, GetServersTiersParameters>, ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetServersTiersData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetServersTiersParameters>, GetServersTiersError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getServersTiers.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetServersTiersParameters, TData = GetServersTiersData>(parameters: ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetServersTiersData, GetServersTiersError, OperationInfiniteData<TData, GetServersTiersParameters>, ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetServersTiersData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetServersTiersParameters>, GetServersTiersError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getServersTiersTotal = qraft.v1Service.getServersTiers.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError> | QueryFiltersByQueryKey<GetServersTiersSchema, GetServersTiersData, TInfinite, GetServersTiersParameters, GetServersTiersError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getServersTiersResults = qraft.v1Service.getServersTiers.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getServersTiersResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getServersTiersCombinedResults = qraft.v1Service.getServersTiers.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getServersTiersCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetServersTiersSchema, GetServersTiersParameters, GetServersTiersData, GetServersTiersError>>, TCombinedResult = Array<UseQueryResult<GetServersTiersData, GetServersTiersError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetServersTiersData, GetServersTiersError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetServersTiersParameters | void): ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getServersTiers.useQuery()
         * ```
         */
        useQuery<TData = GetServersTiersData>(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options?: Omit<UndefinedInitialDataOptions<GetServersTiersData, GetServersTiersError, TData, ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>>, "queryKey">): UseQueryResult<TData, GetServersTiersError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getServersTiers.useQuery()
         * ```
         */
        useQuery<TData = GetServersTiersData>(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options: Omit<DefinedInitialDataOptions<GetServersTiersData, GetServersTiersError, TData, ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetServersTiersError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getServersTiers.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetServersTiersParameters, TData = GetServersTiersData>(parameters: ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetServersTiersData, GetServersTiersError, OperationInfiniteData<TData, GetServersTiersParameters>, GetServersTiersData, ServiceOperationInfiniteQueryKey<GetServersTiersSchema, GetServersTiersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetServersTiersData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetServersTiersParameters>, GetServersTiersError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetServersTiersSchema, GetServersTiersParameters, GetServersTiersData, GetServersTiersError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetServersTiersData, GetServersTiersError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetServersTiersData, GetServersTiersError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetServersTiersData>(parameters: ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters> | (GetServersTiersParameters | void), options?: Omit<UseSuspenseQueryOptions<GetServersTiersData, GetServersTiersError, TData, ServiceOperationQueryKey<GetServersTiersSchema, GetServersTiersParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetServersTiersError | Error>;
        schema: GetServersTiersSchema;
        types: {
            parameters: GetServersTiersParameters;
            data: GetServersTiersData;
            error: GetServersTiersError;
        };
    };
    deleteStripeSubscriptionsSubscriptionIdCancel: {
        /**/
        getMutationKey(parameters: DeleteStripeSubscriptionsSubscriptionIdCancelParameters | void): ServiceOperationMutationKey<DeleteStripeSubscriptionsSubscriptionIdCancelSchema, DeleteStripeSubscriptionsSubscriptionIdCancelParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useMutation({
         *     path: {
         *         subscriptionId: subscriptionId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         subscriptionId: subscriptionId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteStripeSubscriptionsSubscriptionIdCancelBody, TContext = unknown>(parameters: DeleteStripeSubscriptionsSubscriptionIdCancelParameters, options?: ServiceOperationUseMutationOptions<DeleteStripeSubscriptionsSubscriptionIdCancelSchema, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, TVariables, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext>): UseMutationResult<DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useMutation({
         *     path: {
         *         subscriptionId: subscriptionId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         subscriptionId: subscriptionId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteStripeSubscriptionsSubscriptionIdCancelSchema, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, TVariables, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext>): UseMutationResult<DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteStripeSubscriptionsSubscriptionIdCancelTotal = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteStripeSubscriptionsSubscriptionIdCancelTotal = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useIsMutating({
         *     parameters: {
         *         path: {
         *             subscriptionId: subscriptionId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext> | MutationFiltersByMutationKey<DeleteStripeSubscriptionsSubscriptionIdCancelSchema, DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext> | MutationFiltersByMutationKey<DeleteStripeSubscriptionsSubscriptionIdCancelSchema, DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelParameters>, client?: (schema: DeleteStripeSubscriptionsSubscriptionIdCancelSchema, options: ServiceOperationMutationFnOptions<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelParameters>) => Promise<RequestFnResponse<DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelError>>): Promise<RequestFnResponse<DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteStripeSubscriptionsSubscriptionIdCancelPendingMutationVariables = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteStripeSubscriptionsSubscriptionIdCancelMutationData = qraft.v1Service.deleteStripeSubscriptionsSubscriptionIdCancel.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 subscriptionId: subscriptionId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelError, MutationVariables<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext> | MutationFiltersByMutationKey<DeleteStripeSubscriptionsSubscriptionIdCancelSchema, DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelParameters, DeleteStripeSubscriptionsSubscriptionIdCancelError, TContext>;
            select?: (mutation: Mutation<DeleteStripeSubscriptionsSubscriptionIdCancelData, DeleteStripeSubscriptionsSubscriptionIdCancelError, MutationVariables<DeleteStripeSubscriptionsSubscriptionIdCancelBody, DeleteStripeSubscriptionsSubscriptionIdCancelParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteStripeSubscriptionsSubscriptionIdCancelSchema;
        types: {
            parameters: DeleteStripeSubscriptionsSubscriptionIdCancelParameters;
            data: DeleteStripeSubscriptionsSubscriptionIdCancelData;
            error: DeleteStripeSubscriptionsSubscriptionIdCancelError;
            body: DeleteStripeSubscriptionsSubscriptionIdCancelBody;
        };
    };
    getStripeSubscriptionsUser: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetStripeSubscriptionsUserParameters | void): ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripeSubscriptionsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options?: Omit<UndefinedInitialDataOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, TData, ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>>, "queryKey">): UseQueryResult<TData, GetStripeSubscriptionsUserError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripeSubscriptionsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options: Omit<DefinedInitialDataOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, TData, ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetStripeSubscriptionsUserError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetStripeSubscriptionsUserParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters, TPageParam, GetStripeSubscriptionsUserError>): Promise<OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetStripeSubscriptionsUserParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters, TPageParam, GetStripeSubscriptionsUserError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetStripeSubscriptionsUserParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters, TPageParam, GetStripeSubscriptionsUserError>): Promise<OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | void): Promise<GetStripeSubscriptionsUserData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | void): Promise<GetStripeSubscriptionsUserData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void)): OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>,
            data: NoInfer<OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>,
            data: GetStripeSubscriptionsUserData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void)): GetStripeSubscriptionsUserData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void)): QueryState<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetStripeSubscriptionsUserParameters | ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | void): QueryState<OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters>, GetStripeSubscriptionsUserError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetStripeSubscriptionsUserParameters, TMeta, TSignal> | void), client?: (schema: GetStripeSubscriptionsUserSchema, options: {
            parameters: GetStripeSubscriptionsUserParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>): Promise<RequestFnResponse<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetStripeSubscriptionsUserParameters | ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters>> | undefined, NoInfer<OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>, updater: Updater<NoInfer<GetStripeSubscriptionsUserData> | undefined, NoInfer<GetStripeSubscriptionsUserData> | undefined>, options?: SetDataOptions): Array<GetStripeSubscriptionsUserData | undefined>;
        /**/
        setQueryData(parameters: (GetStripeSubscriptionsUserParameters | undefined) | ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>, updater: Updater<NoInfer<GetStripeSubscriptionsUserData> | undefined, NoInfer<GetStripeSubscriptionsUserData> | undefined>, options?: SetDataOptions): GetStripeSubscriptionsUserData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetStripeSubscriptionsUserParameters | void): ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeSubscriptionsUser.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetStripeSubscriptionsUserParameters, TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, OperationInfiniteData<TData, GetStripeSubscriptionsUserParameters>, ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetStripeSubscriptionsUserData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetStripeSubscriptionsUserParameters>, GetStripeSubscriptionsUserError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeSubscriptionsUser.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetStripeSubscriptionsUserParameters, TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, OperationInfiniteData<TData, GetStripeSubscriptionsUserParameters>, ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetStripeSubscriptionsUserData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetStripeSubscriptionsUserParameters>, GetStripeSubscriptionsUserError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getStripeSubscriptionsUserTotal = qraft.v1Service.getStripeSubscriptionsUser.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError> | QueryFiltersByQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserData, TInfinite, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getStripeSubscriptionsUserResults = qraft.v1Service.getStripeSubscriptionsUser.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getStripeSubscriptionsUserResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getStripeSubscriptionsUserCombinedResults = qraft.v1Service.getStripeSubscriptionsUser.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getStripeSubscriptionsUserCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>, TCombinedResult = Array<UseQueryResult<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetStripeSubscriptionsUserParameters | void): ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripeSubscriptionsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options?: Omit<UndefinedInitialDataOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, TData, ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>>, "queryKey">): UseQueryResult<TData, GetStripeSubscriptionsUserError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripeSubscriptionsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options: Omit<DefinedInitialDataOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, TData, ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetStripeSubscriptionsUserError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeSubscriptionsUser.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetStripeSubscriptionsUserParameters, TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, OperationInfiniteData<TData, GetStripeSubscriptionsUserParameters>, GetStripeSubscriptionsUserData, ServiceOperationInfiniteQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetStripeSubscriptionsUserData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripeSubscriptionsUserParameters>, GetStripeSubscriptionsUserError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters, GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetStripeSubscriptionsUserData>(parameters: ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters> | (GetStripeSubscriptionsUserParameters | void), options?: Omit<UseSuspenseQueryOptions<GetStripeSubscriptionsUserData, GetStripeSubscriptionsUserError, TData, ServiceOperationQueryKey<GetStripeSubscriptionsUserSchema, GetStripeSubscriptionsUserParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetStripeSubscriptionsUserError | Error>;
        schema: GetStripeSubscriptionsUserSchema;
        types: {
            parameters: GetStripeSubscriptionsUserParameters;
            data: GetStripeSubscriptionsUserData;
            error: GetStripeSubscriptionsUserError;
        };
    };
    postStripeSubscriptionsUpsert: {
        /**/
        getMutationKey(parameters: PostStripeSubscriptionsUpsertParameters | void): ServiceOperationMutationKey<PostStripeSubscriptionsUpsertSchema, PostStripeSubscriptionsUpsertParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeSubscriptionsUpsert.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeSubscriptionsUpsert.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostStripeSubscriptionsUpsertBody, TContext = unknown>(parameters: PostStripeSubscriptionsUpsertParameters, options?: ServiceOperationUseMutationOptions<PostStripeSubscriptionsUpsertSchema, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, TVariables, PostStripeSubscriptionsUpsertError, TContext>): UseMutationResult<PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeSubscriptionsUpsert.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeSubscriptionsUpsert.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostStripeSubscriptionsUpsertSchema, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, TVariables, PostStripeSubscriptionsUpsertError, TContext>): UseMutationResult<PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postStripeSubscriptionsUpsertTotal = qraft.v1Service.postStripeSubscriptionsUpsert.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postStripeSubscriptionsUpsertTotal = qraft.v1Service.postStripeSubscriptionsUpsert.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, PostStripeSubscriptionsUpsertError, TContext> | MutationFiltersByMutationKey<PostStripeSubscriptionsUpsertSchema, PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, PostStripeSubscriptionsUpsertError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, PostStripeSubscriptionsUpsertError, TContext> | MutationFiltersByMutationKey<PostStripeSubscriptionsUpsertSchema, PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, PostStripeSubscriptionsUpsertError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertParameters>, client?: (schema: PostStripeSubscriptionsUpsertSchema, options: ServiceOperationMutationFnOptions<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertParameters>) => Promise<RequestFnResponse<PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertError>>): Promise<RequestFnResponse<PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postStripeSubscriptionsUpsertPendingMutationVariables = qraft.v1Service.postStripeSubscriptionsUpsert.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postStripeSubscriptionsUpsertMutationData = qraft.v1Service.postStripeSubscriptionsUpsert.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertError, MutationVariables<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, PostStripeSubscriptionsUpsertError, TContext> | MutationFiltersByMutationKey<PostStripeSubscriptionsUpsertSchema, PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertParameters, PostStripeSubscriptionsUpsertError, TContext>;
            select?: (mutation: Mutation<PostStripeSubscriptionsUpsertData, PostStripeSubscriptionsUpsertError, MutationVariables<PostStripeSubscriptionsUpsertBody, PostStripeSubscriptionsUpsertParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostStripeSubscriptionsUpsertSchema;
        types: {
            parameters: PostStripeSubscriptionsUpsertParameters;
            data: PostStripeSubscriptionsUpsertData;
            error: PostStripeSubscriptionsUpsertError;
            body: PostStripeSubscriptionsUpsertBody;
        };
    };
    getStripePaymentMethodsUser: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetStripePaymentMethodsUserParameters | void): ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options?: Omit<UndefinedInitialDataOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, TData, ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>>, "queryKey">): UseQueryResult<TData, GetStripePaymentMethodsUserError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options: Omit<DefinedInitialDataOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, TData, ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetStripePaymentMethodsUserError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetStripePaymentMethodsUserParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters, TPageParam, GetStripePaymentMethodsUserError>): Promise<OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetStripePaymentMethodsUserParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters, TPageParam, GetStripePaymentMethodsUserError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetStripePaymentMethodsUserParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters, TPageParam, GetStripePaymentMethodsUserError>): Promise<OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | void): Promise<GetStripePaymentMethodsUserData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | void): Promise<GetStripePaymentMethodsUserData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void)): OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>,
            data: NoInfer<OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>,
            data: GetStripePaymentMethodsUserData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void)): GetStripePaymentMethodsUserData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void)): QueryState<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetStripePaymentMethodsUserParameters | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | void): QueryState<OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters>, GetStripePaymentMethodsUserError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetStripePaymentMethodsUserParameters, TMeta, TSignal> | void), client?: (schema: GetStripePaymentMethodsUserSchema, options: {
            parameters: GetStripePaymentMethodsUserParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>): Promise<RequestFnResponse<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetStripePaymentMethodsUserParameters | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters>> | undefined, NoInfer<OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>, updater: Updater<NoInfer<GetStripePaymentMethodsUserData> | undefined, NoInfer<GetStripePaymentMethodsUserData> | undefined>, options?: SetDataOptions): Array<GetStripePaymentMethodsUserData | undefined>;
        /**/
        setQueryData(parameters: (GetStripePaymentMethodsUserParameters | undefined) | ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>, updater: Updater<NoInfer<GetStripePaymentMethodsUserData> | undefined, NoInfer<GetStripePaymentMethodsUserData> | undefined>, options?: SetDataOptions): GetStripePaymentMethodsUserData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetStripePaymentMethodsUserParameters | void): ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethodsUser.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetStripePaymentMethodsUserParameters, TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, OperationInfiniteData<TData, GetStripePaymentMethodsUserParameters>, ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetStripePaymentMethodsUserData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetStripePaymentMethodsUserParameters>, GetStripePaymentMethodsUserError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethodsUser.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetStripePaymentMethodsUserParameters, TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, OperationInfiniteData<TData, GetStripePaymentMethodsUserParameters>, ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetStripePaymentMethodsUserData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetStripePaymentMethodsUserParameters>, GetStripePaymentMethodsUserError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getStripePaymentMethodsUserTotal = qraft.v1Service.getStripePaymentMethodsUser.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError> | QueryFiltersByQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserData, TInfinite, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getStripePaymentMethodsUserResults = qraft.v1Service.getStripePaymentMethodsUser.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getStripePaymentMethodsUserResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getStripePaymentMethodsUserCombinedResults = qraft.v1Service.getStripePaymentMethodsUser.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getStripePaymentMethodsUserCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>, TCombinedResult = Array<UseQueryResult<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetStripePaymentMethodsUserParameters | void): ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options?: Omit<UndefinedInitialDataOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, TData, ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>>, "queryKey">): UseQueryResult<TData, GetStripePaymentMethodsUserError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsUser.useQuery()
         * ```
         */
        useQuery<TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options: Omit<DefinedInitialDataOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, TData, ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetStripePaymentMethodsUserError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethodsUser.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetStripePaymentMethodsUserParameters, TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, OperationInfiniteData<TData, GetStripePaymentMethodsUserParameters>, GetStripePaymentMethodsUserData, ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetStripePaymentMethodsUserData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripePaymentMethodsUserParameters>, GetStripePaymentMethodsUserError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters, GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetStripePaymentMethodsUserData>(parameters: ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters> | (GetStripePaymentMethodsUserParameters | void), options?: Omit<UseSuspenseQueryOptions<GetStripePaymentMethodsUserData, GetStripePaymentMethodsUserError, TData, ServiceOperationQueryKey<GetStripePaymentMethodsUserSchema, GetStripePaymentMethodsUserParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetStripePaymentMethodsUserError | Error>;
        schema: GetStripePaymentMethodsUserSchema;
        types: {
            parameters: GetStripePaymentMethodsUserParameters;
            data: GetStripePaymentMethodsUserData;
            error: GetStripePaymentMethodsUserError;
        };
    };
    postStripePaymentMethodsAttach: {
        /**/
        getMutationKey(parameters: PostStripePaymentMethodsAttachParameters | void): ServiceOperationMutationKey<PostStripePaymentMethodsAttachSchema, PostStripePaymentMethodsAttachParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsAttach.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsAttach.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostStripePaymentMethodsAttachBody, TContext = unknown>(parameters: PostStripePaymentMethodsAttachParameters, options?: ServiceOperationUseMutationOptions<PostStripePaymentMethodsAttachSchema, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, TVariables, PostStripePaymentMethodsAttachError, TContext>): UseMutationResult<PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsAttach.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsAttach.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostStripePaymentMethodsAttachSchema, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, TVariables, PostStripePaymentMethodsAttachError, TContext>): UseMutationResult<PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postStripePaymentMethodsAttachTotal = qraft.v1Service.postStripePaymentMethodsAttach.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postStripePaymentMethodsAttachTotal = qraft.v1Service.postStripePaymentMethodsAttach.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, PostStripePaymentMethodsAttachError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsAttachSchema, PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, PostStripePaymentMethodsAttachError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, PostStripePaymentMethodsAttachError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsAttachSchema, PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, PostStripePaymentMethodsAttachError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachParameters>, client?: (schema: PostStripePaymentMethodsAttachSchema, options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachParameters>) => Promise<RequestFnResponse<PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachError>>): Promise<RequestFnResponse<PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postStripePaymentMethodsAttachPendingMutationVariables = qraft.v1Service.postStripePaymentMethodsAttach.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postStripePaymentMethodsAttachMutationData = qraft.v1Service.postStripePaymentMethodsAttach.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachError, MutationVariables<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, PostStripePaymentMethodsAttachError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsAttachSchema, PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachParameters, PostStripePaymentMethodsAttachError, TContext>;
            select?: (mutation: Mutation<PostStripePaymentMethodsAttachData, PostStripePaymentMethodsAttachError, MutationVariables<PostStripePaymentMethodsAttachBody, PostStripePaymentMethodsAttachParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostStripePaymentMethodsAttachSchema;
        types: {
            parameters: PostStripePaymentMethodsAttachParameters;
            data: PostStripePaymentMethodsAttachData;
            error: PostStripePaymentMethodsAttachError;
            body: PostStripePaymentMethodsAttachBody;
        };
    };
    postStripePaymentMethodsDefault: {
        /**/
        getMutationKey(parameters: PostStripePaymentMethodsDefaultParameters | void): ServiceOperationMutationKey<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostStripePaymentMethodsDefaultBody, TContext = unknown>(parameters: PostStripePaymentMethodsDefaultParameters, options?: ServiceOperationUseMutationOptions<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, TVariables, PostStripePaymentMethodsDefaultError, TContext>): UseMutationResult<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, TVariables, PostStripePaymentMethodsDefaultError, TContext>): UseMutationResult<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postStripePaymentMethodsDefaultTotal = qraft.v1Service.postStripePaymentMethodsDefault.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postStripePaymentMethodsDefaultTotal = qraft.v1Service.postStripePaymentMethodsDefault.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, PostStripePaymentMethodsDefaultError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, PostStripePaymentMethodsDefaultError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, PostStripePaymentMethodsDefaultError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, PostStripePaymentMethodsDefaultError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>, client?: (schema: PostStripePaymentMethodsDefaultSchema, options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>) => Promise<RequestFnResponse<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError>>): Promise<RequestFnResponse<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postStripePaymentMethodsDefaultPendingMutationVariables = qraft.v1Service.postStripePaymentMethodsDefault.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postStripePaymentMethodsDefaultMutationData = qraft.v1Service.postStripePaymentMethodsDefault.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError, MutationVariables<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, PostStripePaymentMethodsDefaultError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultParameters, PostStripePaymentMethodsDefaultError, TContext>;
            select?: (mutation: Mutation<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError, MutationVariables<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostStripePaymentMethodsDefaultSchema;
        types: {
            parameters: PostStripePaymentMethodsDefaultParameters;
            data: PostStripePaymentMethodsDefaultData;
            error: PostStripePaymentMethodsDefaultError;
            body: PostStripePaymentMethodsDefaultBody;
        };
    };
    deleteStripePaymentMethods: {
        /**/
        getMutationKey(parameters: DeleteStripePaymentMethodsParameters | void): ServiceOperationMutationKey<DeleteStripePaymentMethodsSchema, DeleteStripePaymentMethodsParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethods.useMutation({
         *     query: {
         *         paymentMethodId: paymentMethodId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethods.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         paymentMethodId: paymentMethodId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteStripePaymentMethodsBody, TContext = unknown>(parameters: DeleteStripePaymentMethodsParameters, options?: ServiceOperationUseMutationOptions<DeleteStripePaymentMethodsSchema, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, TVariables, DeleteStripePaymentMethodsError, TContext>): UseMutationResult<DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethods.useMutation({
         *     query: {
         *         paymentMethodId: paymentMethodId
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethods.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     query: {
         *         paymentMethodId: paymentMethodId
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteStripePaymentMethodsSchema, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, TVariables, DeleteStripePaymentMethodsError, TContext>): UseMutationResult<DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteStripePaymentMethodsTotal = qraft.v1Service.deleteStripePaymentMethods.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteStripePaymentMethodsTotal = qraft.v1Service.deleteStripePaymentMethods.useIsMutating({
         *     parameters: {
         *         query: {
         *             paymentMethodId: paymentMethodId
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, DeleteStripePaymentMethodsError, TContext> | MutationFiltersByMutationKey<DeleteStripePaymentMethodsSchema, DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, DeleteStripePaymentMethodsError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, DeleteStripePaymentMethodsError, TContext> | MutationFiltersByMutationKey<DeleteStripePaymentMethodsSchema, DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, DeleteStripePaymentMethodsError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsParameters>, client?: (schema: DeleteStripePaymentMethodsSchema, options: ServiceOperationMutationFnOptions<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsParameters>) => Promise<RequestFnResponse<DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsError>>): Promise<RequestFnResponse<DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteStripePaymentMethodsPendingMutationVariables = qraft.v1Service.deleteStripePaymentMethods.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteStripePaymentMethodsMutationData = qraft.v1Service.deleteStripePaymentMethods.useMutationState({
         *     filters: {
         *         parameters: {
         *             query: {
         *                 paymentMethodId: paymentMethodId
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsError, MutationVariables<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, DeleteStripePaymentMethodsError, TContext> | MutationFiltersByMutationKey<DeleteStripePaymentMethodsSchema, DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsParameters, DeleteStripePaymentMethodsError, TContext>;
            select?: (mutation: Mutation<DeleteStripePaymentMethodsData, DeleteStripePaymentMethodsError, MutationVariables<DeleteStripePaymentMethodsBody, DeleteStripePaymentMethodsParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteStripePaymentMethodsSchema;
        types: {
            parameters: DeleteStripePaymentMethodsParameters;
            data: DeleteStripePaymentMethodsData;
            error: DeleteStripePaymentMethodsError;
            body: DeleteStripePaymentMethodsBody;
        };
    };
    postStripePaymentMethodsSetupIntent: {
        /**/
        getMutationKey(parameters: PostStripePaymentMethodsSetupIntentParameters | void): ServiceOperationMutationKey<PostStripePaymentMethodsSetupIntentSchema, PostStripePaymentMethodsSetupIntentParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetupIntent.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetupIntent.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostStripePaymentMethodsSetupIntentBody, TContext = unknown>(parameters: PostStripePaymentMethodsSetupIntentParameters, options?: ServiceOperationUseMutationOptions<PostStripePaymentMethodsSetupIntentSchema, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, TVariables, PostStripePaymentMethodsSetupIntentError, TContext>): UseMutationResult<PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetupIntent.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetupIntent.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostStripePaymentMethodsSetupIntentSchema, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, TVariables, PostStripePaymentMethodsSetupIntentError, TContext>): UseMutationResult<PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postStripePaymentMethodsSetupIntentTotal = qraft.v1Service.postStripePaymentMethodsSetupIntent.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postStripePaymentMethodsSetupIntentTotal = qraft.v1Service.postStripePaymentMethodsSetupIntent.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, PostStripePaymentMethodsSetupIntentError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsSetupIntentSchema, PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, PostStripePaymentMethodsSetupIntentError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, PostStripePaymentMethodsSetupIntentError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsSetupIntentSchema, PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, PostStripePaymentMethodsSetupIntentError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentParameters>, client?: (schema: PostStripePaymentMethodsSetupIntentSchema, options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentParameters>) => Promise<RequestFnResponse<PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentError>>): Promise<RequestFnResponse<PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postStripePaymentMethodsSetupIntentPendingMutationVariables = qraft.v1Service.postStripePaymentMethodsSetupIntent.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postStripePaymentMethodsSetupIntentMutationData = qraft.v1Service.postStripePaymentMethodsSetupIntent.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentError, MutationVariables<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, PostStripePaymentMethodsSetupIntentError, TContext> | MutationFiltersByMutationKey<PostStripePaymentMethodsSetupIntentSchema, PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentParameters, PostStripePaymentMethodsSetupIntentError, TContext>;
            select?: (mutation: Mutation<PostStripePaymentMethodsSetupIntentData, PostStripePaymentMethodsSetupIntentError, MutationVariables<PostStripePaymentMethodsSetupIntentBody, PostStripePaymentMethodsSetupIntentParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostStripePaymentMethodsSetupIntentSchema;
        types: {
            parameters: PostStripePaymentMethodsSetupIntentParameters;
            data: PostStripePaymentMethodsSetupIntentData;
            error: PostStripePaymentMethodsSetupIntentError;
            body: PostStripePaymentMethodsSetupIntentBody;
        };
    };
    postStripeWebhooks: {
        /**/
        getMutationKey(parameters: PostStripeWebhooksParameters | void): ServiceOperationMutationKey<PostStripeWebhooksSchema, PostStripeWebhooksParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeWebhooks.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeWebhooks.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostStripeWebhooksBody, TContext = unknown>(parameters: PostStripeWebhooksParameters, options?: ServiceOperationUseMutationOptions<PostStripeWebhooksSchema, PostStripeWebhooksData, PostStripeWebhooksParameters, TVariables, PostStripeWebhooksError, TContext>): UseMutationResult<PostStripeWebhooksData, PostStripeWebhooksError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeWebhooks.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postStripeWebhooks.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostStripeWebhooksBody, PostStripeWebhooksParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostStripeWebhooksSchema, PostStripeWebhooksData, PostStripeWebhooksParameters, TVariables, PostStripeWebhooksError, TContext>): UseMutationResult<PostStripeWebhooksData, PostStripeWebhooksError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postStripeWebhooksTotal = qraft.v1Service.postStripeWebhooks.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postStripeWebhooksTotal = qraft.v1Service.postStripeWebhooks.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostStripeWebhooksBody, PostStripeWebhooksData, PostStripeWebhooksParameters, PostStripeWebhooksError, TContext> | MutationFiltersByMutationKey<PostStripeWebhooksSchema, PostStripeWebhooksBody, PostStripeWebhooksData, PostStripeWebhooksParameters, PostStripeWebhooksError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostStripeWebhooksBody, PostStripeWebhooksData, PostStripeWebhooksParameters, PostStripeWebhooksError, TContext> | MutationFiltersByMutationKey<PostStripeWebhooksSchema, PostStripeWebhooksBody, PostStripeWebhooksData, PostStripeWebhooksParameters, PostStripeWebhooksError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostStripeWebhooksBody, PostStripeWebhooksParameters>, client?: (schema: PostStripeWebhooksSchema, options: ServiceOperationMutationFnOptions<PostStripeWebhooksBody, PostStripeWebhooksParameters>) => Promise<RequestFnResponse<PostStripeWebhooksData, PostStripeWebhooksError>>): Promise<RequestFnResponse<PostStripeWebhooksData, PostStripeWebhooksError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postStripeWebhooksPendingMutationVariables = qraft.v1Service.postStripeWebhooks.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postStripeWebhooksMutationData = qraft.v1Service.postStripeWebhooks.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostStripeWebhooksData, PostStripeWebhooksError, MutationVariables<PostStripeWebhooksBody, PostStripeWebhooksParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostStripeWebhooksBody, PostStripeWebhooksData, PostStripeWebhooksParameters, PostStripeWebhooksError, TContext> | MutationFiltersByMutationKey<PostStripeWebhooksSchema, PostStripeWebhooksBody, PostStripeWebhooksData, PostStripeWebhooksParameters, PostStripeWebhooksError, TContext>;
            select?: (mutation: Mutation<PostStripeWebhooksData, PostStripeWebhooksError, MutationVariables<PostStripeWebhooksBody, PostStripeWebhooksParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostStripeWebhooksSchema;
        types: {
            parameters: PostStripeWebhooksParameters;
            data: PostStripeWebhooksData;
            error: PostStripeWebhooksError;
            body: PostStripeWebhooksBody;
        };
    };
    getUsers: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetUsersParameters | void): ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options?: Omit<UndefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): UseQueryResult<TData, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<DefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetUsersError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetUsersParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, TPageParam, GetUsersError>): Promise<OperationInfiniteData<GetUsersData, GetUsersParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetUsersParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, TPageParam, GetUsersError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetUsersParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetUsersSchema, GetUsersData, GetUsersParameters, TPageParam, GetUsersError>): Promise<OperationInfiniteData<GetUsersData, GetUsersParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, GetUsersError> | void): Promise<GetUsersData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, GetUsersError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetUsersSchema, GetUsersData, GetUsersParameters, GetUsersError> | void): Promise<GetUsersData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void)): OperationInfiniteData<GetUsersData, GetUsersParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>,
            data: NoInfer<OperationInfiniteData<GetUsersData, GetUsersParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>,
            data: GetUsersData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void)): GetUsersData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void)): QueryState<GetUsersData, GetUsersError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetUsersParameters | ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | void): QueryState<OperationInfiniteData<GetUsersData, GetUsersParameters>, GetUsersError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetUsersSchema, GetUsersParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetUsersParameters, TMeta, TSignal> | void), client?: (schema: GetUsersSchema, options: {
            parameters: GetUsersParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetUsersData, GetUsersError>>): Promise<RequestFnResponse<GetUsersData, GetUsersError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetUsersParameters | ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetUsersData, GetUsersParameters>> | undefined, NoInfer<OperationInfiniteData<GetUsersData, GetUsersParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetUsersData, GetUsersParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, updater: Updater<NoInfer<GetUsersData> | undefined, NoInfer<GetUsersData> | undefined>, options?: SetDataOptions): Array<GetUsersData | undefined>;
        /**/
        setQueryData(parameters: (GetUsersParameters | undefined) | ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>, updater: Updater<NoInfer<GetUsersData> | undefined, NoInfer<GetUsersData> | undefined>, options?: SetDataOptions): GetUsersData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetUsersParameters | void): ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsers.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUsersParameters, TData = GetUsersData>(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetUsersData, GetUsersError, OperationInfiniteData<TData, GetUsersParameters>, ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUsersData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetUsersParameters>, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsers.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUsersParameters, TData = GetUsersData>(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetUsersData, GetUsersError, OperationInfiniteData<TData, GetUsersParameters>, ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUsersData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetUsersParameters>, GetUsersError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getUsersTotal = qraft.v1Service.getUsers.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getUsersResults = qraft.v1Service.getUsers.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getUsersResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getUsersCombinedResults = qraft.v1Service.getUsers.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getUsersCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetUsersSchema, GetUsersParameters, GetUsersData, GetUsersError>>, TCombinedResult = Array<UseQueryResult<GetUsersData, GetUsersError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetUsersData, GetUsersError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetUsersParameters | void): ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options?: Omit<UndefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): UseQueryResult<TData, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<DefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsers.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetUsersParameters, TData = GetUsersData>(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetUsersData, GetUsersError, OperationInfiniteData<TData, GetUsersParameters>, GetUsersData, ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUsersData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUsersParameters>, GetUsersError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUsersSchema, GetUsersParameters, GetUsersData, GetUsersError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetUsersData, GetUsersError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUsersData, GetUsersError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options?: Omit<UseSuspenseQueryOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetUsersError | Error>;
        schema: GetUsersSchema;
        types: {
            parameters: GetUsersParameters;
            data: GetUsersData;
            error: GetUsersError;
        };
    };
}
export const v1Service: {
    getAuthLogin: {
        schema: {
            method: "get";
            url: "/v1/auth/login";
        };
    };
    getAuthCloseWindowMessage: {
        schema: {
            method: "get";
            url: "/v1/auth/close-window-message";
        };
    };
    getAuthLogout: {
        schema: {
            method: "get";
            url: "/v1/auth/logout";
        };
    };
    getAuthWhoami: {
        schema: {
            method: "get";
            url: "/v1/auth/whoami";
        };
    };
    getAuthMe: {
        schema: {
            method: "get";
            url: "/v1/auth/me";
        };
    };
    postCliDockerPush: {
        schema: {
            method: "post";
            url: "/v1/cli/docker/push";
        };
    };
    getCliRepos: {
        schema: {
            method: "get";
            url: "/v1/cli/repos";
        };
    };
    postCliRepos: {
        schema: {
            method: "post";
            url: "/v1/cli/repos";
            mediaType: [
                "application/json"
            ];
        };
    };
    postCliProjectsProjectIdDeployments: {
        schema: {
            method: "post";
            url: "/v1/cli/projects/{projectId}/deployments";
            mediaType: [
                "application/json"
            ];
        };
    };
    postCliProjects: {
        schema: {
            method: "post";
            url: "/v1/cli/projects";
            mediaType: [
                "application/json"
            ];
        };
    };
    getCliProjectsProjectId: {
        schema: {
            method: "get";
            url: "/v1/cli/projects/{projectId}";
        };
    };
    postCliProjectsGetProjectByRepoUrl: {
        schema: {
            method: "post";
            url: "/v1/cli/projects/get-project-by-repo-url";
            mediaType: [
                "application/json"
            ];
        };
    };
    postCliProjectsProjectIdRestore: {
        schema: {
            method: "post";
            url: "/v1/cli/projects/{projectId}/restore";
        };
    };
    getCliLocations: {
        schema: {
            method: "get";
            url: "/v1/cli/locations";
        };
    };
    postCliModulesAdd: {
        schema: {
            method: "post";
            url: "/v1/cli/modules/add";
            mediaType: [
                "application/json"
            ];
        };
    };
    postCliModulesForkModules: {
        schema: {
            method: "post";
            url: "/v1/cli/modules/fork-modules";
            mediaType: [
                "application/json"
            ];
        };
    };
    getExample: {
        schema: {
            method: "get";
            url: "/v1/example";
        };
    };
    getGithubGetInstallAppUrl: {
        schema: {
            method: "get";
            url: "/v1/github/get-install-app-url";
        };
    };
    getGithubGetInstalledOrganizations: {
        schema: {
            method: "get";
            url: "/v1/github/get-installed-organizations";
        };
    };
    postGithubSetDeafultOrganization: {
        schema: {
            method: "post";
            url: "/v1/github/set-deafult-organization";
            mediaType: [
                "application/json"
            ];
        };
    };
    getGithubPlayground: {
        schema: {
            method: "get";
            url: "/v1/github/playground";
        };
    };
    get: {
        schema: {
            method: "get";
            url: "/v1";
        };
    };
    getEnv: {
        schema: {
            method: "get";
            url: "/v1/env";
        };
    };
    putHostingDeploymentsDeploymentIdStatus: {
        schema: {
            method: "put";
            url: "/v1/hosting/deployments/{deploymentId}/status";
            mediaType: [
                "application/json"
            ];
        };
    };
    postHostingDeploymentsDeploymentIdLogs: {
        schema: {
            method: "post";
            url: "/v1/hosting/deployments/{deploymentId}/logs";
            mediaType: [
                "application/json"
            ];
        };
    };
    getHostingProjectsProjectIdDomains: {
        schema: {
            method: "get";
            url: "/v1/hosting/projects/{projectId}/domains";
        };
    };
    getHostingProjectsProjectIdEnvironment: {
        schema: {
            method: "get";
            url: "/v1/hosting/projects/{projectId}/environment";
        };
    };
    putHostingProjectsProjectIdState: {
        schema: {
            method: "put";
            url: "/v1/hosting/projects/{projectId}/state";
            mediaType: [
                "application/json"
            ];
        };
    };
    postHostingProjectsProjectIdServices: {
        schema: {
            method: "post";
            url: "/v1/hosting/projects/{projectId}/services";
            mediaType: [
                "application/json"
            ];
        };
    };
    postMailSend: {
        schema: {
            method: "post";
            url: "/v1/mail/send";
            mediaType: [
                "application/json"
            ];
        };
    };
    getProjectsProjectId: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}";
        };
    };
    deleteProjectsProjectId: {
        schema: {
            method: "delete";
            url: "/v1/projects/{projectId}";
        };
    };
    getProjectsProjectIdStart: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/start";
        };
    };
    getProjectsProjectIdStop: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/stop";
        };
    };
    getProjects: {
        schema: {
            method: "get";
            url: "/v1/projects";
        };
    };
    getProjectsProjectIdUsageSpan: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/{usageSpan}";
        };
    };
    getProjectsProjectIdDeployments: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/deployments";
        };
    };
    getProjectsProjectIdDeploymentsDeploymentId: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/deployments/{deploymentId}";
        };
    };
    getProjectsProjectIdDeploymentsDeploymentIdLogs: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/deployments/{deploymentId}/logs";
        };
    };
    getProjectsProjectIdEnvironment: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/environment";
        };
    };
    putProjectsProjectIdEnvironment: {
        schema: {
            method: "put";
            url: "/v1/projects/{projectId}/environment";
            mediaType: [
                "application/json"
            ];
        };
    };
    putProjectsProjectIdEnvironmentChangeAutoDeploy: {
        schema: {
            method: "put";
            url: "/v1/projects/{projectId}/environment/change-auto-deploy";
            mediaType: [
                "application/json"
            ];
        };
    };
    getProjectsProjectIdDomains: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/domains";
        };
    };
    postProjectsProjectIdDomains: {
        schema: {
            method: "post";
            url: "/v1/projects/{projectId}/domains";
            mediaType: [
                "application/json"
            ];
        };
    };
    deleteProjectsProjectIdDomainsDomainId: {
        schema: {
            method: "delete";
            url: "/v1/projects/{projectId}/domains/{domainId}";
        };
    };
    getProjectsProjectIdDomainsDomainIdVerify: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/domains/{domainId}/verify";
        };
    };
    postProjectsProjectIdDomainsDomainIdSetPrimary: {
        schema: {
            method: "post";
            url: "/v1/projects/{projectId}/domains/{domainId}/set-primary";
        };
    };
    getProjectsProjectIdDomainsDomainIdParent: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/domains/{domainId}/parent";
        };
    };
    getProjectsProjectIdServices: {
        schema: {
            method: "get";
            url: "/v1/projects/{projectId}/services";
        };
    };
    putProjectsProjectIdServices: {
        schema: {
            method: "put";
            url: "/v1/projects/{projectId}/services";
            mediaType: [
                "application/json"
            ];
        };
    };
    postServers: {
        schema: {
            method: "post";
            url: "/v1/servers";
        };
    };
    putServers: {
        schema: {
            method: "put";
            url: "/v1/servers";
            mediaType: [
                "application/json"
            ];
        };
    };
    getServersTiers: {
        schema: {
            method: "get";
            url: "/v1/servers/tiers";
        };
    };
    deleteStripeSubscriptionsSubscriptionIdCancel: {
        schema: {
            method: "delete";
            url: "/v1/stripe/subscriptions/{subscriptionId}/cancel";
            mediaType: [
                "application/json"
            ];
        };
    };
    getStripeSubscriptionsUser: {
        schema: {
            method: "get";
            url: "/v1/stripe/subscriptions/user";
        };
    };
    postStripeSubscriptionsUpsert: {
        schema: {
            method: "post";
            url: "/v1/stripe/subscriptions/upsert";
            mediaType: [
                "application/json"
            ];
        };
    };
    getStripePaymentMethodsUser: {
        schema: {
            method: "get";
            url: "/v1/stripe/payment-methods/user";
        };
    };
    postStripePaymentMethodsAttach: {
        schema: {
            method: "post";
            url: "/v1/stripe/payment-methods/attach";
            mediaType: [
                "application/json"
            ];
        };
    };
    postStripePaymentMethodsDefault: {
        schema: {
            method: "post";
            url: "/v1/stripe/payment-methods/default";
            mediaType: [
                "application/json"
            ];
        };
    };
    deleteStripePaymentMethods: {
        schema: {
            method: "delete";
            url: "/v1/stripe/payment-methods";
        };
    };
    postStripePaymentMethodsSetupIntent: {
        schema: {
            method: "post";
            url: "/v1/stripe/payment-methods/setup-intent";
        };
    };
    postStripeWebhooks: {
        schema: {
            method: "post";
            url: "/v1/stripe/webhooks";
        };
    };
    getUsers: {
        schema: {
            method: "get";
            url: "/v1/users";
        };
    };
} = {
    getAuthLogin: {
        schema: {
            method: "get",
            url: "/v1/auth/login"
        }
    },
    getAuthCloseWindowMessage: {
        schema: {
            method: "get",
            url: "/v1/auth/close-window-message"
        }
    },
    getAuthLogout: {
        schema: {
            method: "get",
            url: "/v1/auth/logout"
        }
    },
    getAuthWhoami: {
        schema: {
            method: "get",
            url: "/v1/auth/whoami"
        }
    },
    getAuthMe: {
        schema: {
            method: "get",
            url: "/v1/auth/me"
        }
    },
    postCliDockerPush: {
        schema: {
            method: "post",
            url: "/v1/cli/docker/push"
        }
    },
    getCliRepos: {
        schema: {
            method: "get",
            url: "/v1/cli/repos"
        }
    },
    postCliRepos: {
        schema: {
            method: "post",
            url: "/v1/cli/repos",
            mediaType: ["application/json"]
        }
    },
    postCliProjectsProjectIdDeployments: {
        schema: {
            method: "post",
            url: "/v1/cli/projects/{projectId}/deployments",
            mediaType: ["application/json"]
        }
    },
    postCliProjects: {
        schema: {
            method: "post",
            url: "/v1/cli/projects",
            mediaType: ["application/json"]
        }
    },
    getCliProjectsProjectId: {
        schema: {
            method: "get",
            url: "/v1/cli/projects/{projectId}"
        }
    },
    postCliProjectsGetProjectByRepoUrl: {
        schema: {
            method: "post",
            url: "/v1/cli/projects/get-project-by-repo-url",
            mediaType: ["application/json"]
        }
    },
    postCliProjectsProjectIdRestore: {
        schema: {
            method: "post",
            url: "/v1/cli/projects/{projectId}/restore"
        }
    },
    getCliLocations: {
        schema: {
            method: "get",
            url: "/v1/cli/locations"
        }
    },
    postCliModulesAdd: {
        schema: {
            method: "post",
            url: "/v1/cli/modules/add",
            mediaType: ["application/json"]
        }
    },
    postCliModulesForkModules: {
        schema: {
            method: "post",
            url: "/v1/cli/modules/fork-modules",
            mediaType: ["application/json"]
        }
    },
    getExample: {
        schema: {
            method: "get",
            url: "/v1/example"
        }
    },
    getGithubGetInstallAppUrl: {
        schema: {
            method: "get",
            url: "/v1/github/get-install-app-url"
        }
    },
    getGithubGetInstalledOrganizations: {
        schema: {
            method: "get",
            url: "/v1/github/get-installed-organizations"
        }
    },
    postGithubSetDeafultOrganization: {
        schema: {
            method: "post",
            url: "/v1/github/set-deafult-organization",
            mediaType: ["application/json"]
        }
    },
    getGithubPlayground: {
        schema: {
            method: "get",
            url: "/v1/github/playground"
        }
    },
    get: {
        schema: {
            method: "get",
            url: "/v1"
        }
    },
    getEnv: {
        schema: {
            method: "get",
            url: "/v1/env"
        }
    },
    putHostingDeploymentsDeploymentIdStatus: {
        schema: {
            method: "put",
            url: "/v1/hosting/deployments/{deploymentId}/status",
            mediaType: ["application/json"]
        }
    },
    postHostingDeploymentsDeploymentIdLogs: {
        schema: {
            method: "post",
            url: "/v1/hosting/deployments/{deploymentId}/logs",
            mediaType: ["application/json"]
        }
    },
    getHostingProjectsProjectIdDomains: {
        schema: {
            method: "get",
            url: "/v1/hosting/projects/{projectId}/domains"
        }
    },
    getHostingProjectsProjectIdEnvironment: {
        schema: {
            method: "get",
            url: "/v1/hosting/projects/{projectId}/environment"
        }
    },
    putHostingProjectsProjectIdState: {
        schema: {
            method: "put",
            url: "/v1/hosting/projects/{projectId}/state",
            mediaType: ["application/json"]
        }
    },
    postHostingProjectsProjectIdServices: {
        schema: {
            method: "post",
            url: "/v1/hosting/projects/{projectId}/services",
            mediaType: ["application/json"]
        }
    },
    postMailSend: {
        schema: {
            method: "post",
            url: "/v1/mail/send",
            mediaType: ["application/json"]
        }
    },
    getProjectsProjectId: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}"
        }
    },
    deleteProjectsProjectId: {
        schema: {
            method: "delete",
            url: "/v1/projects/{projectId}"
        }
    },
    getProjectsProjectIdStart: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/start"
        }
    },
    getProjectsProjectIdStop: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/stop"
        }
    },
    getProjects: {
        schema: {
            method: "get",
            url: "/v1/projects"
        }
    },
    getProjectsProjectIdUsageSpan: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/{usageSpan}"
        }
    },
    getProjectsProjectIdDeployments: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/deployments"
        }
    },
    getProjectsProjectIdDeploymentsDeploymentId: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/deployments/{deploymentId}"
        }
    },
    getProjectsProjectIdDeploymentsDeploymentIdLogs: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/deployments/{deploymentId}/logs"
        }
    },
    getProjectsProjectIdEnvironment: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/environment"
        }
    },
    putProjectsProjectIdEnvironment: {
        schema: {
            method: "put",
            url: "/v1/projects/{projectId}/environment",
            mediaType: ["application/json"]
        }
    },
    putProjectsProjectIdEnvironmentChangeAutoDeploy: {
        schema: {
            method: "put",
            url: "/v1/projects/{projectId}/environment/change-auto-deploy",
            mediaType: ["application/json"]
        }
    },
    getProjectsProjectIdDomains: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/domains"
        }
    },
    postProjectsProjectIdDomains: {
        schema: {
            method: "post",
            url: "/v1/projects/{projectId}/domains",
            mediaType: ["application/json"]
        }
    },
    deleteProjectsProjectIdDomainsDomainId: {
        schema: {
            method: "delete",
            url: "/v1/projects/{projectId}/domains/{domainId}"
        }
    },
    getProjectsProjectIdDomainsDomainIdVerify: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/domains/{domainId}/verify"
        }
    },
    postProjectsProjectIdDomainsDomainIdSetPrimary: {
        schema: {
            method: "post",
            url: "/v1/projects/{projectId}/domains/{domainId}/set-primary"
        }
    },
    getProjectsProjectIdDomainsDomainIdParent: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/domains/{domainId}/parent"
        }
    },
    getProjectsProjectIdServices: {
        schema: {
            method: "get",
            url: "/v1/projects/{projectId}/services"
        }
    },
    putProjectsProjectIdServices: {
        schema: {
            method: "put",
            url: "/v1/projects/{projectId}/services",
            mediaType: ["application/json"]
        }
    },
    postServers: {
        schema: {
            method: "post",
            url: "/v1/servers"
        }
    },
    putServers: {
        schema: {
            method: "put",
            url: "/v1/servers",
            mediaType: ["application/json"]
        }
    },
    getServersTiers: {
        schema: {
            method: "get",
            url: "/v1/servers/tiers"
        }
    },
    deleteStripeSubscriptionsSubscriptionIdCancel: {
        schema: {
            method: "delete",
            url: "/v1/stripe/subscriptions/{subscriptionId}/cancel",
            mediaType: ["application/json"]
        }
    },
    getStripeSubscriptionsUser: {
        schema: {
            method: "get",
            url: "/v1/stripe/subscriptions/user"
        }
    },
    postStripeSubscriptionsUpsert: {
        schema: {
            method: "post",
            url: "/v1/stripe/subscriptions/upsert",
            mediaType: ["application/json"]
        }
    },
    getStripePaymentMethodsUser: {
        schema: {
            method: "get",
            url: "/v1/stripe/payment-methods/user"
        }
    },
    postStripePaymentMethodsAttach: {
        schema: {
            method: "post",
            url: "/v1/stripe/payment-methods/attach",
            mediaType: ["application/json"]
        }
    },
    postStripePaymentMethodsDefault: {
        schema: {
            method: "post",
            url: "/v1/stripe/payment-methods/default",
            mediaType: ["application/json"]
        }
    },
    deleteStripePaymentMethods: {
        schema: {
            method: "delete",
            url: "/v1/stripe/payment-methods"
        }
    },
    postStripePaymentMethodsSetupIntent: {
        schema: {
            method: "post",
            url: "/v1/stripe/payment-methods/setup-intent"
        }
    },
    postStripeWebhooks: {
        schema: {
            method: "post",
            url: "/v1/stripe/webhooks"
        }
    },
    getUsers: {
        schema: {
            method: "get",
            url: "/v1/users"
        }
    }
};
type GetAuthLoginSchema = {
    method: "get";
    url: "/v1/auth/login";
};
type GetAuthLoginParameters = undefined;
type GetAuthLoginData = unknown;
type GetAuthLoginError = unknown;
type GetAuthCloseWindowMessageSchema = {
    method: "get";
    url: "/v1/auth/close-window-message";
};
type GetAuthCloseWindowMessageParameters = undefined;
type GetAuthCloseWindowMessageData = paths["/v1/auth/close-window-message"]["get"]["responses"]["200"]["content"]["text/plain"];
type GetAuthCloseWindowMessageError = unknown;
type GetAuthLogoutSchema = {
    method: "get";
    url: "/v1/auth/logout";
};
type GetAuthLogoutParameters = undefined;
type GetAuthLogoutData = unknown;
type GetAuthLogoutError = unknown;
type GetAuthWhoamiSchema = {
    method: "get";
    url: "/v1/auth/whoami";
};
type GetAuthWhoamiParameters = undefined;
type GetAuthWhoamiData = unknown;
type GetAuthWhoamiError = unknown;
type GetAuthMeSchema = {
    method: "get";
    url: "/v1/auth/me";
};
type GetAuthMeParameters = undefined;
type GetAuthMeData = paths["/v1/auth/me"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAuthMeError = unknown;
type PostCliDockerPushSchema = {
    method: "post";
    url: "/v1/cli/docker/push";
};
type PostCliDockerPushParameters = paths["/v1/cli/docker/push"]["post"]["parameters"];
type PostCliDockerPushData = unknown;
type PostCliDockerPushError = unknown;
type PostCliDockerPushBody = undefined;
type GetCliReposSchema = {
    method: "get";
    url: "/v1/cli/repos";
};
type GetCliReposParameters = paths["/v1/cli/repos"]["get"]["parameters"];
type GetCliReposData = paths["/v1/cli/repos"]["get"]["responses"]["200"]["content"]["application/json"];
type GetCliReposError = unknown;
type PostCliReposSchema = {
    method: "post";
    url: "/v1/cli/repos";
    mediaType: [
        "application/json"
    ];
};
type PostCliReposParameters = {};
type PostCliReposData = paths["/v1/cli/repos"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliReposError = unknown;
type PostCliReposBody = NonNullable<paths["/v1/cli/repos"]["post"]["requestBody"]>["content"]["application/json"];
type PostCliProjectsProjectIdDeploymentsSchema = {
    method: "post";
    url: "/v1/cli/projects/{projectId}/deployments";
    mediaType: [
        "application/json"
    ];
};
type PostCliProjectsProjectIdDeploymentsParameters = paths["/v1/cli/projects/{projectId}/deployments"]["post"]["parameters"];
type PostCliProjectsProjectIdDeploymentsData = paths["/v1/cli/projects/{projectId}/deployments"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliProjectsProjectIdDeploymentsError = unknown;
type PostCliProjectsProjectIdDeploymentsBody = NonNullable<paths["/v1/cli/projects/{projectId}/deployments"]["post"]["requestBody"]>["content"]["application/json"];
type PostCliProjectsSchema = {
    method: "post";
    url: "/v1/cli/projects";
    mediaType: [
        "application/json"
    ];
};
type PostCliProjectsParameters = {};
type PostCliProjectsData = paths["/v1/cli/projects"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliProjectsError = unknown;
type PostCliProjectsBody = NonNullable<paths["/v1/cli/projects"]["post"]["requestBody"]>["content"]["application/json"];
type GetCliProjectsProjectIdSchema = {
    method: "get";
    url: "/v1/cli/projects/{projectId}";
};
type GetCliProjectsProjectIdParameters = paths["/v1/cli/projects/{projectId}"]["get"]["parameters"];
type GetCliProjectsProjectIdData = paths["/v1/cli/projects/{projectId}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetCliProjectsProjectIdError = unknown;
type PostCliProjectsGetProjectByRepoUrlSchema = {
    method: "post";
    url: "/v1/cli/projects/get-project-by-repo-url";
    mediaType: [
        "application/json"
    ];
};
type PostCliProjectsGetProjectByRepoUrlParameters = {};
type PostCliProjectsGetProjectByRepoUrlData = paths["/v1/cli/projects/get-project-by-repo-url"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliProjectsGetProjectByRepoUrlError = unknown;
type PostCliProjectsGetProjectByRepoUrlBody = NonNullable<paths["/v1/cli/projects/get-project-by-repo-url"]["post"]["requestBody"]>["content"]["application/json"];
type PostCliProjectsProjectIdRestoreSchema = {
    method: "post";
    url: "/v1/cli/projects/{projectId}/restore";
};
type PostCliProjectsProjectIdRestoreParameters = paths["/v1/cli/projects/{projectId}/restore"]["post"]["parameters"];
type PostCliProjectsProjectIdRestoreData = paths["/v1/cli/projects/{projectId}/restore"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliProjectsProjectIdRestoreError = unknown;
type PostCliProjectsProjectIdRestoreBody = undefined;
type GetCliLocationsSchema = {
    method: "get";
    url: "/v1/cli/locations";
};
type GetCliLocationsParameters = undefined;
type GetCliLocationsData = paths["/v1/cli/locations"]["get"]["responses"]["200"]["content"]["application/json"];
type GetCliLocationsError = unknown;
type PostCliModulesAddSchema = {
    method: "post";
    url: "/v1/cli/modules/add";
    mediaType: [
        "application/json"
    ];
};
type PostCliModulesAddParameters = {};
type PostCliModulesAddData = paths["/v1/cli/modules/add"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliModulesAddError = unknown;
type PostCliModulesAddBody = NonNullable<paths["/v1/cli/modules/add"]["post"]["requestBody"]>["content"]["application/json"];
type PostCliModulesForkModulesSchema = {
    method: "post";
    url: "/v1/cli/modules/fork-modules";
    mediaType: [
        "application/json"
    ];
};
type PostCliModulesForkModulesParameters = {};
type PostCliModulesForkModulesData = paths["/v1/cli/modules/fork-modules"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliModulesForkModulesError = unknown;
type PostCliModulesForkModulesBody = NonNullable<paths["/v1/cli/modules/fork-modules"]["post"]["requestBody"]>["content"]["application/json"];
type GetExampleSchema = {
    method: "get";
    url: "/v1/example";
};
type GetExampleParameters = paths["/v1/example"]["get"]["parameters"];
type GetExampleData = paths["/v1/example"]["get"]["responses"]["200"]["content"]["application/json"];
type GetExampleError = unknown;
type GetGithubGetInstallAppUrlSchema = {
    method: "get";
    url: "/v1/github/get-install-app-url";
};
type GetGithubGetInstallAppUrlParameters = undefined;
type GetGithubGetInstallAppUrlData = paths["/v1/github/get-install-app-url"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGithubGetInstallAppUrlError = unknown;
type GetGithubGetInstalledOrganizationsSchema = {
    method: "get";
    url: "/v1/github/get-installed-organizations";
};
type GetGithubGetInstalledOrganizationsParameters = undefined;
type GetGithubGetInstalledOrganizationsData = paths["/v1/github/get-installed-organizations"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGithubGetInstalledOrganizationsError = unknown;
type PostGithubSetDeafultOrganizationSchema = {
    method: "post";
    url: "/v1/github/set-deafult-organization";
    mediaType: [
        "application/json"
    ];
};
type PostGithubSetDeafultOrganizationParameters = {};
type PostGithubSetDeafultOrganizationData = unknown;
type PostGithubSetDeafultOrganizationError = unknown;
type PostGithubSetDeafultOrganizationBody = NonNullable<paths["/v1/github/set-deafult-organization"]["post"]["requestBody"]>["content"]["application/json"];
type GetGithubPlaygroundSchema = {
    method: "get";
    url: "/v1/github/playground";
};
type GetGithubPlaygroundParameters = undefined;
type GetGithubPlaygroundData = unknown;
type GetGithubPlaygroundError = unknown;
type GetSchema = {
    method: "get";
    url: "/v1";
};
type GetParameters = undefined;
type GetData = paths["/v1"]["get"]["responses"]["200"]["content"]["text/plain"];
type GetError = unknown;
type GetEnvSchema = {
    method: "get";
    url: "/v1/env";
};
type GetEnvParameters = undefined;
type GetEnvData = paths["/v1/env"]["get"]["responses"]["200"]["content"]["text/plain"];
type GetEnvError = unknown;
type PutHostingDeploymentsDeploymentIdStatusSchema = {
    method: "put";
    url: "/v1/hosting/deployments/{deploymentId}/status";
    mediaType: [
        "application/json"
    ];
};
type PutHostingDeploymentsDeploymentIdStatusParameters = paths["/v1/hosting/deployments/{deploymentId}/status"]["put"]["parameters"];
type PutHostingDeploymentsDeploymentIdStatusData = paths["/v1/hosting/deployments/{deploymentId}/status"]["put"]["responses"]["200"]["content"]["application/json"];
type PutHostingDeploymentsDeploymentIdStatusError = unknown;
type PutHostingDeploymentsDeploymentIdStatusBody = NonNullable<paths["/v1/hosting/deployments/{deploymentId}/status"]["put"]["requestBody"]>["content"]["application/json"];
type PostHostingDeploymentsDeploymentIdLogsSchema = {
    method: "post";
    url: "/v1/hosting/deployments/{deploymentId}/logs";
    mediaType: [
        "application/json"
    ];
};
type PostHostingDeploymentsDeploymentIdLogsParameters = paths["/v1/hosting/deployments/{deploymentId}/logs"]["post"]["parameters"];
type PostHostingDeploymentsDeploymentIdLogsData = paths["/v1/hosting/deployments/{deploymentId}/logs"]["post"]["responses"]["200"]["content"]["application/json"];
type PostHostingDeploymentsDeploymentIdLogsError = unknown;
type PostHostingDeploymentsDeploymentIdLogsBody = NonNullable<paths["/v1/hosting/deployments/{deploymentId}/logs"]["post"]["requestBody"]>["content"]["application/json"];
type GetHostingProjectsProjectIdDomainsSchema = {
    method: "get";
    url: "/v1/hosting/projects/{projectId}/domains";
};
type GetHostingProjectsProjectIdDomainsParameters = paths["/v1/hosting/projects/{projectId}/domains"]["get"]["parameters"];
type GetHostingProjectsProjectIdDomainsData = paths["/v1/hosting/projects/{projectId}/domains"]["get"]["responses"]["200"]["content"]["application/json"];
type GetHostingProjectsProjectIdDomainsError = unknown;
type GetHostingProjectsProjectIdEnvironmentSchema = {
    method: "get";
    url: "/v1/hosting/projects/{projectId}/environment";
};
type GetHostingProjectsProjectIdEnvironmentParameters = paths["/v1/hosting/projects/{projectId}/environment"]["get"]["parameters"];
type GetHostingProjectsProjectIdEnvironmentData = paths["/v1/hosting/projects/{projectId}/environment"]["get"]["responses"]["200"]["content"]["application/json"];
type GetHostingProjectsProjectIdEnvironmentError = unknown;
type PutHostingProjectsProjectIdStateSchema = {
    method: "put";
    url: "/v1/hosting/projects/{projectId}/state";
    mediaType: [
        "application/json"
    ];
};
type PutHostingProjectsProjectIdStateParameters = paths["/v1/hosting/projects/{projectId}/state"]["put"]["parameters"];
type PutHostingProjectsProjectIdStateData = paths["/v1/hosting/projects/{projectId}/state"]["put"]["responses"]["200"]["content"]["application/json"];
type PutHostingProjectsProjectIdStateError = unknown;
type PutHostingProjectsProjectIdStateBody = NonNullable<paths["/v1/hosting/projects/{projectId}/state"]["put"]["requestBody"]>["content"]["application/json"];
type PostHostingProjectsProjectIdServicesSchema = {
    method: "post";
    url: "/v1/hosting/projects/{projectId}/services";
    mediaType: [
        "application/json"
    ];
};
type PostHostingProjectsProjectIdServicesParameters = paths["/v1/hosting/projects/{projectId}/services"]["post"]["parameters"];
type PostHostingProjectsProjectIdServicesData = paths["/v1/hosting/projects/{projectId}/services"]["post"]["responses"]["200"]["content"]["application/json"];
type PostHostingProjectsProjectIdServicesError = unknown;
type PostHostingProjectsProjectIdServicesBody = NonNullable<paths["/v1/hosting/projects/{projectId}/services"]["post"]["requestBody"]>["content"]["application/json"];
type PostMailSendSchema = {
    method: "post";
    url: "/v1/mail/send";
    mediaType: [
        "application/json"
    ];
};
type PostMailSendParameters = {};
type PostMailSendData = unknown;
type PostMailSendError = unknown;
type PostMailSendBody = NonNullable<paths["/v1/mail/send"]["post"]["requestBody"]>["content"]["application/json"];
type GetProjectsProjectIdSchema = {
    method: "get";
    url: "/v1/projects/{projectId}";
};
type GetProjectsProjectIdParameters = paths["/v1/projects/{projectId}"]["get"]["parameters"];
type GetProjectsProjectIdData = paths["/v1/projects/{projectId}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdError = unknown;
type DeleteProjectsProjectIdSchema = {
    method: "delete";
    url: "/v1/projects/{projectId}";
};
type DeleteProjectsProjectIdParameters = paths["/v1/projects/{projectId}"]["delete"]["parameters"];
type DeleteProjectsProjectIdData = paths["/v1/projects/{projectId}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteProjectsProjectIdError = unknown;
type DeleteProjectsProjectIdBody = undefined;
type GetProjectsProjectIdStartSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/start";
};
type GetProjectsProjectIdStartParameters = paths["/v1/projects/{projectId}/start"]["get"]["parameters"];
type GetProjectsProjectIdStartData = unknown;
type GetProjectsProjectIdStartError = unknown;
type GetProjectsProjectIdStopSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/stop";
};
type GetProjectsProjectIdStopParameters = paths["/v1/projects/{projectId}/stop"]["get"]["parameters"];
type GetProjectsProjectIdStopData = unknown;
type GetProjectsProjectIdStopError = unknown;
type GetProjectsSchema = {
    method: "get";
    url: "/v1/projects";
};
type GetProjectsParameters = paths["/v1/projects"]["get"]["parameters"];
type GetProjectsData = paths["/v1/projects"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsError = unknown;
type GetProjectsProjectIdUsageSpanSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/{usageSpan}";
};
type GetProjectsProjectIdUsageSpanParameters = paths["/v1/projects/{projectId}/{usageSpan}"]["get"]["parameters"];
type GetProjectsProjectIdUsageSpanData = paths["/v1/projects/{projectId}/{usageSpan}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdUsageSpanError = unknown;
type GetProjectsProjectIdDeploymentsSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/deployments";
};
type GetProjectsProjectIdDeploymentsParameters = paths["/v1/projects/{projectId}/deployments"]["get"]["parameters"];
type GetProjectsProjectIdDeploymentsData = paths["/v1/projects/{projectId}/deployments"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdDeploymentsError = unknown;
type GetProjectsProjectIdDeploymentsDeploymentIdSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/deployments/{deploymentId}";
};
type GetProjectsProjectIdDeploymentsDeploymentIdParameters = paths["/v1/projects/{projectId}/deployments/{deploymentId}"]["get"]["parameters"];
type GetProjectsProjectIdDeploymentsDeploymentIdData = paths["/v1/projects/{projectId}/deployments/{deploymentId}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdDeploymentsDeploymentIdError = unknown;
type GetProjectsProjectIdDeploymentsDeploymentIdLogsSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/deployments/{deploymentId}/logs";
};
type GetProjectsProjectIdDeploymentsDeploymentIdLogsParameters = paths["/v1/projects/{projectId}/deployments/{deploymentId}/logs"]["get"]["parameters"];
type GetProjectsProjectIdDeploymentsDeploymentIdLogsData = paths["/v1/projects/{projectId}/deployments/{deploymentId}/logs"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdDeploymentsDeploymentIdLogsError = unknown;
type GetProjectsProjectIdEnvironmentSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/environment";
};
type GetProjectsProjectIdEnvironmentParameters = paths["/v1/projects/{projectId}/environment"]["get"]["parameters"];
type GetProjectsProjectIdEnvironmentData = paths["/v1/projects/{projectId}/environment"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdEnvironmentError = unknown;
type PutProjectsProjectIdEnvironmentSchema = {
    method: "put";
    url: "/v1/projects/{projectId}/environment";
    mediaType: [
        "application/json"
    ];
};
type PutProjectsProjectIdEnvironmentParameters = paths["/v1/projects/{projectId}/environment"]["put"]["parameters"];
type PutProjectsProjectIdEnvironmentData = unknown;
type PutProjectsProjectIdEnvironmentError = unknown;
type PutProjectsProjectIdEnvironmentBody = NonNullable<paths["/v1/projects/{projectId}/environment"]["put"]["requestBody"]>["content"]["application/json"];
type PutProjectsProjectIdEnvironmentChangeAutoDeploySchema = {
    method: "put";
    url: "/v1/projects/{projectId}/environment/change-auto-deploy";
    mediaType: [
        "application/json"
    ];
};
type PutProjectsProjectIdEnvironmentChangeAutoDeployParameters = paths["/v1/projects/{projectId}/environment/change-auto-deploy"]["put"]["parameters"];
type PutProjectsProjectIdEnvironmentChangeAutoDeployData = paths["/v1/projects/{projectId}/environment/change-auto-deploy"]["put"]["responses"]["200"]["content"]["application/json"];
type PutProjectsProjectIdEnvironmentChangeAutoDeployError = unknown;
type PutProjectsProjectIdEnvironmentChangeAutoDeployBody = NonNullable<paths["/v1/projects/{projectId}/environment/change-auto-deploy"]["put"]["requestBody"]>["content"]["application/json"];
type GetProjectsProjectIdDomainsSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/domains";
};
type GetProjectsProjectIdDomainsParameters = paths["/v1/projects/{projectId}/domains"]["get"]["parameters"];
type GetProjectsProjectIdDomainsData = paths["/v1/projects/{projectId}/domains"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdDomainsError = unknown;
type PostProjectsProjectIdDomainsSchema = {
    method: "post";
    url: "/v1/projects/{projectId}/domains";
    mediaType: [
        "application/json"
    ];
};
type PostProjectsProjectIdDomainsParameters = paths["/v1/projects/{projectId}/domains"]["post"]["parameters"];
type PostProjectsProjectIdDomainsData = paths["/v1/projects/{projectId}/domains"]["post"]["responses"]["200"]["content"]["application/json"];
type PostProjectsProjectIdDomainsError = unknown;
type PostProjectsProjectIdDomainsBody = NonNullable<paths["/v1/projects/{projectId}/domains"]["post"]["requestBody"]>["content"]["application/json"];
type DeleteProjectsProjectIdDomainsDomainIdSchema = {
    method: "delete";
    url: "/v1/projects/{projectId}/domains/{domainId}";
};
type DeleteProjectsProjectIdDomainsDomainIdParameters = paths["/v1/projects/{projectId}/domains/{domainId}"]["delete"]["parameters"];
type DeleteProjectsProjectIdDomainsDomainIdData = paths["/v1/projects/{projectId}/domains/{domainId}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteProjectsProjectIdDomainsDomainIdError = unknown;
type DeleteProjectsProjectIdDomainsDomainIdBody = undefined;
type GetProjectsProjectIdDomainsDomainIdVerifySchema = {
    method: "get";
    url: "/v1/projects/{projectId}/domains/{domainId}/verify";
};
type GetProjectsProjectIdDomainsDomainIdVerifyParameters = paths["/v1/projects/{projectId}/domains/{domainId}/verify"]["get"]["parameters"];
type GetProjectsProjectIdDomainsDomainIdVerifyData = paths["/v1/projects/{projectId}/domains/{domainId}/verify"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdDomainsDomainIdVerifyError = unknown;
type PostProjectsProjectIdDomainsDomainIdSetPrimarySchema = {
    method: "post";
    url: "/v1/projects/{projectId}/domains/{domainId}/set-primary";
};
type PostProjectsProjectIdDomainsDomainIdSetPrimaryParameters = paths["/v1/projects/{projectId}/domains/{domainId}/set-primary"]["post"]["parameters"];
type PostProjectsProjectIdDomainsDomainIdSetPrimaryData = paths["/v1/projects/{projectId}/domains/{domainId}/set-primary"]["post"]["responses"]["200"]["content"]["application/json"];
type PostProjectsProjectIdDomainsDomainIdSetPrimaryError = unknown;
type PostProjectsProjectIdDomainsDomainIdSetPrimaryBody = undefined;
type GetProjectsProjectIdDomainsDomainIdParentSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/domains/{domainId}/parent";
};
type GetProjectsProjectIdDomainsDomainIdParentParameters = paths["/v1/projects/{projectId}/domains/{domainId}/parent"]["get"]["parameters"];
type GetProjectsProjectIdDomainsDomainIdParentData = paths["/v1/projects/{projectId}/domains/{domainId}/parent"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdDomainsDomainIdParentError = unknown;
type GetProjectsProjectIdServicesSchema = {
    method: "get";
    url: "/v1/projects/{projectId}/services";
};
type GetProjectsProjectIdServicesParameters = paths["/v1/projects/{projectId}/services"]["get"]["parameters"];
type GetProjectsProjectIdServicesData = paths["/v1/projects/{projectId}/services"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProjectsProjectIdServicesError = unknown;
type PutProjectsProjectIdServicesSchema = {
    method: "put";
    url: "/v1/projects/{projectId}/services";
    mediaType: [
        "application/json"
    ];
};
type PutProjectsProjectIdServicesParameters = paths["/v1/projects/{projectId}/services"]["put"]["parameters"];
type PutProjectsProjectIdServicesData = paths["/v1/projects/{projectId}/services"]["put"]["responses"]["200"]["content"]["application/json"];
type PutProjectsProjectIdServicesError = unknown;
type PutProjectsProjectIdServicesBody = NonNullable<paths["/v1/projects/{projectId}/services"]["put"]["requestBody"]>["content"]["application/json"];
type PostServersSchema = {
    method: "post";
    url: "/v1/servers";
};
type PostServersParameters = {};
type PostServersData = paths["/v1/servers"]["post"]["responses"]["200"]["content"]["text/plain"];
type PostServersError = unknown;
type PostServersBody = undefined;
type PutServersSchema = {
    method: "put";
    url: "/v1/servers";
    mediaType: [
        "application/json"
    ];
};
type PutServersParameters = {};
type PutServersData = paths["/v1/servers"]["put"]["responses"]["200"]["content"]["application/json"];
type PutServersError = unknown;
type PutServersBody = NonNullable<paths["/v1/servers"]["put"]["requestBody"]>["content"]["application/json"];
type GetServersTiersSchema = {
    method: "get";
    url: "/v1/servers/tiers";
};
type GetServersTiersParameters = undefined;
type GetServersTiersData = paths["/v1/servers/tiers"]["get"]["responses"]["200"]["content"]["application/json"];
type GetServersTiersError = unknown;
type DeleteStripeSubscriptionsSubscriptionIdCancelSchema = {
    method: "delete";
    url: "/v1/stripe/subscriptions/{subscriptionId}/cancel";
    mediaType: [
        "application/json"
    ];
};
type DeleteStripeSubscriptionsSubscriptionIdCancelParameters = paths["/v1/stripe/subscriptions/{subscriptionId}/cancel"]["delete"]["parameters"];
type DeleteStripeSubscriptionsSubscriptionIdCancelData = paths["/v1/stripe/subscriptions/{subscriptionId}/cancel"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteStripeSubscriptionsSubscriptionIdCancelError = unknown;
type DeleteStripeSubscriptionsSubscriptionIdCancelBody = NonNullable<paths["/v1/stripe/subscriptions/{subscriptionId}/cancel"]["delete"]["requestBody"]>["content"]["application/json"];
type GetStripeSubscriptionsUserSchema = {
    method: "get";
    url: "/v1/stripe/subscriptions/user";
};
type GetStripeSubscriptionsUserParameters = undefined;
type GetStripeSubscriptionsUserData = paths["/v1/stripe/subscriptions/user"]["get"]["responses"]["200"]["content"]["application/json"];
type GetStripeSubscriptionsUserError = unknown;
type PostStripeSubscriptionsUpsertSchema = {
    method: "post";
    url: "/v1/stripe/subscriptions/upsert";
    mediaType: [
        "application/json"
    ];
};
type PostStripeSubscriptionsUpsertParameters = {};
type PostStripeSubscriptionsUpsertData = unknown;
type PostStripeSubscriptionsUpsertError = unknown;
type PostStripeSubscriptionsUpsertBody = NonNullable<paths["/v1/stripe/subscriptions/upsert"]["post"]["requestBody"]>["content"]["application/json"];
type GetStripePaymentMethodsUserSchema = {
    method: "get";
    url: "/v1/stripe/payment-methods/user";
};
type GetStripePaymentMethodsUserParameters = undefined;
type GetStripePaymentMethodsUserData = paths["/v1/stripe/payment-methods/user"]["get"]["responses"]["200"]["content"]["application/json"];
type GetStripePaymentMethodsUserError = unknown;
type PostStripePaymentMethodsAttachSchema = {
    method: "post";
    url: "/v1/stripe/payment-methods/attach";
    mediaType: [
        "application/json"
    ];
};
type PostStripePaymentMethodsAttachParameters = {};
type PostStripePaymentMethodsAttachData = paths["/v1/stripe/payment-methods/attach"]["post"]["responses"]["200"]["content"]["application/json"];
type PostStripePaymentMethodsAttachError = unknown;
type PostStripePaymentMethodsAttachBody = NonNullable<paths["/v1/stripe/payment-methods/attach"]["post"]["requestBody"]>["content"]["application/json"];
type PostStripePaymentMethodsDefaultSchema = {
    method: "post";
    url: "/v1/stripe/payment-methods/default";
    mediaType: [
        "application/json"
    ];
};
type PostStripePaymentMethodsDefaultParameters = {};
type PostStripePaymentMethodsDefaultData = paths["/v1/stripe/payment-methods/default"]["post"]["responses"]["200"]["content"]["application/json"];
type PostStripePaymentMethodsDefaultError = unknown;
type PostStripePaymentMethodsDefaultBody = NonNullable<paths["/v1/stripe/payment-methods/default"]["post"]["requestBody"]>["content"]["application/json"];
type DeleteStripePaymentMethodsSchema = {
    method: "delete";
    url: "/v1/stripe/payment-methods";
};
type DeleteStripePaymentMethodsParameters = paths["/v1/stripe/payment-methods"]["delete"]["parameters"];
type DeleteStripePaymentMethodsData = paths["/v1/stripe/payment-methods"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteStripePaymentMethodsError = unknown;
type DeleteStripePaymentMethodsBody = undefined;
type PostStripePaymentMethodsSetupIntentSchema = {
    method: "post";
    url: "/v1/stripe/payment-methods/setup-intent";
};
type PostStripePaymentMethodsSetupIntentParameters = {};
type PostStripePaymentMethodsSetupIntentData = paths["/v1/stripe/payment-methods/setup-intent"]["post"]["responses"]["200"]["content"]["application/json"];
type PostStripePaymentMethodsSetupIntentError = unknown;
type PostStripePaymentMethodsSetupIntentBody = undefined;
type PostStripeWebhooksSchema = {
    method: "post";
    url: "/v1/stripe/webhooks";
};
type PostStripeWebhooksParameters = {};
type PostStripeWebhooksData = unknown;
type PostStripeWebhooksError = unknown;
type PostStripeWebhooksBody = undefined;
type GetUsersSchema = {
    method: "get";
    url: "/v1/users";
};
type GetUsersParameters = undefined;
type GetUsersData = paths["/v1/users"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUsersError = unknown;
