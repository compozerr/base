/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { AreAllOptional, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, Updater } from "@tanstack/query-core";
import type { DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface V1Service {
    getAuthLogin: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthLoginParameters | void): ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLoginError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthLoginParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, TPageParam, GetAuthLoginError>): Promise<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthLoginParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, TPageParam, GetAuthLoginError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthLoginParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, TPageParam, GetAuthLoginError>): Promise<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, GetAuthLoginError> | void): Promise<GetAuthLoginData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, GetAuthLoginError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthLoginSchema, GetAuthLoginData, GetAuthLoginParameters, GetAuthLoginError> | void): Promise<GetAuthLoginData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void)): OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>,
            data: GetAuthLoginData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void)): GetAuthLoginData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void)): QueryState<GetAuthLoginData, GetAuthLoginError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthLoginParameters | ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | void): QueryState<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>, GetAuthLoginError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthLoginSchema, GetAuthLoginParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthLoginParameters, TMeta, TSignal> | void), client?: (schema: GetAuthLoginSchema, options: {
            parameters: GetAuthLoginParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthLoginData, GetAuthLoginError>>): Promise<RequestFnResponse<GetAuthLoginData, GetAuthLoginError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthLoginParameters | ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthLoginData, GetAuthLoginParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>, updater: Updater<NoInfer<GetAuthLoginData> | undefined, NoInfer<GetAuthLoginData> | undefined>, options?: SetDataOptions): Array<GetAuthLoginData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthLoginParameters | undefined) | ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, updater: Updater<NoInfer<GetAuthLoginData> | undefined, NoInfer<GetAuthLoginData> | undefined>, options?: SetDataOptions): GetAuthLoginData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthLoginParameters | void): ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogin.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLoginParameters, TData = GetAuthLoginData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthLoginData, GetAuthLoginError, OperationInfiniteData<TData, GetAuthLoginParameters>, ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLoginData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogin.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLoginParameters, TData = GetAuthLoginData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthLoginData, GetAuthLoginError, OperationInfiniteData<TData, GetAuthLoginParameters>, ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLoginData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthLoginTotal = qraft.v1Service.getAuthLogin.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError> | QueryFiltersByQueryKey<GetAuthLoginSchema, GetAuthLoginData, TInfinite, GetAuthLoginParameters, GetAuthLoginError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthLoginResults = qraft.v1Service.getAuthLogin.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLoginResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthLoginCombinedResults = qraft.v1Service.getAuthLogin.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLoginCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthLoginSchema, GetAuthLoginParameters, GetAuthLoginData, GetAuthLoginError>>, TCombinedResult = Array<UseQueryResult<GetAuthLoginData, GetAuthLoginError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthLoginData, GetAuthLoginError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthLoginParameters | void): ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogin.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLoginError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogin.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthLoginParameters, TData = GetAuthLoginData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthLoginData, GetAuthLoginError, OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginData, ServiceOperationInfiniteQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLoginData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLoginParameters>, GetAuthLoginError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthLoginSchema, GetAuthLoginParameters, GetAuthLoginData, GetAuthLoginError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthLoginData, GetAuthLoginError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthLoginData, GetAuthLoginError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthLoginData>(parameters: ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters> | (GetAuthLoginParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthLoginData, GetAuthLoginError, TData, ServiceOperationQueryKey<GetAuthLoginSchema, GetAuthLoginParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthLoginError | Error>;
        schema: GetAuthLoginSchema;
        types: {
            parameters: GetAuthLoginParameters;
            data: GetAuthLoginData;
            error: GetAuthLoginError;
        };
    };
    getAuthCloseWindowMessage: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthCloseWindowMessageParameters | void): ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): UseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, TPageParam, GetAuthCloseWindowMessageError>): Promise<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, TPageParam, GetAuthCloseWindowMessageError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthCloseWindowMessageParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, TPageParam, GetAuthCloseWindowMessageError>): Promise<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | void): Promise<GetAuthCloseWindowMessageData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | void): Promise<GetAuthCloseWindowMessageData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void)): OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>,
            data: GetAuthCloseWindowMessageData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void)): GetAuthCloseWindowMessageData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void)): QueryState<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthCloseWindowMessageParameters | ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | void): QueryState<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthCloseWindowMessageParameters, TMeta, TSignal> | void), client?: (schema: GetAuthCloseWindowMessageSchema, options: {
            parameters: GetAuthCloseWindowMessageParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>): Promise<RequestFnResponse<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthCloseWindowMessageParameters | ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>, updater: Updater<NoInfer<GetAuthCloseWindowMessageData> | undefined, NoInfer<GetAuthCloseWindowMessageData> | undefined>, options?: SetDataOptions): Array<GetAuthCloseWindowMessageData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthCloseWindowMessageParameters | undefined) | ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, updater: Updater<NoInfer<GetAuthCloseWindowMessageData> | undefined, NoInfer<GetAuthCloseWindowMessageData> | undefined>, options?: SetDataOptions): GetAuthCloseWindowMessageData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthCloseWindowMessageParameters | void): ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthCloseWindowMessage.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters, TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthCloseWindowMessageData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthCloseWindowMessage.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters, TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthCloseWindowMessageData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthCloseWindowMessageTotal = qraft.v1Service.getAuthCloseWindowMessage.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError> | QueryFiltersByQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageData, TInfinite, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthCloseWindowMessageResults = qraft.v1Service.getAuthCloseWindowMessage.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthCloseWindowMessageResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthCloseWindowMessageCombinedResults = qraft.v1Service.getAuthCloseWindowMessage.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthCloseWindowMessageCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>, TCombinedResult = Array<UseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthCloseWindowMessageParameters | void): ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): UseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthCloseWindowMessage.useQuery()
         * ```
         */
        useQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthCloseWindowMessage.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthCloseWindowMessageParameters, TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageData, ServiceOperationInfiniteQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthCloseWindowMessageData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthCloseWindowMessageParameters>, GetAuthCloseWindowMessageError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters, GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthCloseWindowMessageData>(parameters: ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters> | (GetAuthCloseWindowMessageParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthCloseWindowMessageData, GetAuthCloseWindowMessageError, TData, ServiceOperationQueryKey<GetAuthCloseWindowMessageSchema, GetAuthCloseWindowMessageParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthCloseWindowMessageError | Error>;
        schema: GetAuthCloseWindowMessageSchema;
        types: {
            parameters: GetAuthCloseWindowMessageParameters;
            data: GetAuthCloseWindowMessageData;
            error: GetAuthCloseWindowMessageError;
        };
    };
    getAuthLogout: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthLogoutParameters | void): ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLogoutError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthLogoutParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, TPageParam, GetAuthLogoutError>): Promise<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthLogoutParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, TPageParam, GetAuthLogoutError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthLogoutParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, TPageParam, GetAuthLogoutError>): Promise<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, GetAuthLogoutError> | void): Promise<GetAuthLogoutData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, GetAuthLogoutError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthLogoutSchema, GetAuthLogoutData, GetAuthLogoutParameters, GetAuthLogoutError> | void): Promise<GetAuthLogoutData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void)): OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>,
            data: GetAuthLogoutData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void)): GetAuthLogoutData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void)): QueryState<GetAuthLogoutData, GetAuthLogoutError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthLogoutParameters | ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | void): QueryState<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>, GetAuthLogoutError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthLogoutParameters, TMeta, TSignal> | void), client?: (schema: GetAuthLogoutSchema, options: {
            parameters: GetAuthLogoutParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthLogoutData, GetAuthLogoutError>>): Promise<RequestFnResponse<GetAuthLogoutData, GetAuthLogoutError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthLogoutParameters | ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthLogoutData, GetAuthLogoutParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>, updater: Updater<NoInfer<GetAuthLogoutData> | undefined, NoInfer<GetAuthLogoutData> | undefined>, options?: SetDataOptions): Array<GetAuthLogoutData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthLogoutParameters | undefined) | ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, updater: Updater<NoInfer<GetAuthLogoutData> | undefined, NoInfer<GetAuthLogoutData> | undefined>, options?: SetDataOptions): GetAuthLogoutData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthLogoutParameters | void): ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogout.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLogoutParameters, TData = GetAuthLogoutData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthLogoutData, GetAuthLogoutError, OperationInfiniteData<TData, GetAuthLogoutParameters>, ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLogoutData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogout.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthLogoutParameters, TData = GetAuthLogoutData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthLogoutData, GetAuthLogoutError, OperationInfiniteData<TData, GetAuthLogoutParameters>, ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLogoutData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthLogoutTotal = qraft.v1Service.getAuthLogout.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError> | QueryFiltersByQueryKey<GetAuthLogoutSchema, GetAuthLogoutData, TInfinite, GetAuthLogoutParameters, GetAuthLogoutError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthLogoutResults = qraft.v1Service.getAuthLogout.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLogoutResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthLogoutCombinedResults = qraft.v1Service.getAuthLogout.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthLogoutCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthLogoutSchema, GetAuthLogoutParameters, GetAuthLogoutData, GetAuthLogoutError>>, TCombinedResult = Array<UseQueryResult<GetAuthLogoutData, GetAuthLogoutError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthLogoutData, GetAuthLogoutError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthLogoutParameters | void): ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): UseQueryResult<TData, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthLogout.useQuery()
         * ```
         */
        useQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthLogoutError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthLogout.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthLogoutParameters, TData = GetAuthLogoutData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthLogoutData, GetAuthLogoutError, OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutData, ServiceOperationInfiniteQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthLogoutData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthLogoutParameters>, GetAuthLogoutError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthLogoutSchema, GetAuthLogoutParameters, GetAuthLogoutData, GetAuthLogoutError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthLogoutData, GetAuthLogoutError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthLogoutData, GetAuthLogoutError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthLogoutData>(parameters: ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters> | (GetAuthLogoutParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthLogoutData, GetAuthLogoutError, TData, ServiceOperationQueryKey<GetAuthLogoutSchema, GetAuthLogoutParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthLogoutError | Error>;
        schema: GetAuthLogoutSchema;
        types: {
            parameters: GetAuthLogoutParameters;
            data: GetAuthLogoutData;
            error: GetAuthLogoutError;
        };
    };
    getAuthWhoami: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthWhoamiParameters | void): ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): UseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthWhoamiParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, TPageParam, GetAuthWhoamiError>): Promise<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthWhoamiParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, TPageParam, GetAuthWhoamiError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthWhoamiParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, TPageParam, GetAuthWhoamiError>): Promise<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, GetAuthWhoamiError> | void): Promise<GetAuthWhoamiData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, GetAuthWhoamiError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthWhoamiSchema, GetAuthWhoamiData, GetAuthWhoamiParameters, GetAuthWhoamiError> | void): Promise<GetAuthWhoamiData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void)): OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>,
            data: GetAuthWhoamiData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void)): GetAuthWhoamiData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void)): QueryState<GetAuthWhoamiData, GetAuthWhoamiError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthWhoamiParameters | ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | void): QueryState<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>, GetAuthWhoamiError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthWhoamiParameters, TMeta, TSignal> | void), client?: (schema: GetAuthWhoamiSchema, options: {
            parameters: GetAuthWhoamiParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthWhoamiData, GetAuthWhoamiError>>): Promise<RequestFnResponse<GetAuthWhoamiData, GetAuthWhoamiError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthWhoamiParameters | ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthWhoamiData, GetAuthWhoamiParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>, updater: Updater<NoInfer<GetAuthWhoamiData> | undefined, NoInfer<GetAuthWhoamiData> | undefined>, options?: SetDataOptions): Array<GetAuthWhoamiData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthWhoamiParameters | undefined) | ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, updater: Updater<NoInfer<GetAuthWhoamiData> | undefined, NoInfer<GetAuthWhoamiData> | undefined>, options?: SetDataOptions): GetAuthWhoamiData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthWhoamiParameters | void): ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthWhoami.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthWhoamiParameters, TData = GetAuthWhoamiData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthWhoamiData, GetAuthWhoamiError, OperationInfiniteData<TData, GetAuthWhoamiParameters>, ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthWhoamiData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthWhoami.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthWhoamiParameters, TData = GetAuthWhoamiData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthWhoamiData, GetAuthWhoamiError, OperationInfiniteData<TData, GetAuthWhoamiParameters>, ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthWhoamiData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthWhoamiTotal = qraft.v1Service.getAuthWhoami.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError> | QueryFiltersByQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiData, TInfinite, GetAuthWhoamiParameters, GetAuthWhoamiError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthWhoamiResults = qraft.v1Service.getAuthWhoami.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthWhoamiResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthWhoamiCombinedResults = qraft.v1Service.getAuthWhoami.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthWhoamiCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthWhoamiSchema, GetAuthWhoamiParameters, GetAuthWhoamiData, GetAuthWhoamiError>>, TCombinedResult = Array<UseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthWhoamiParameters | void): ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): UseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthWhoami.useQuery()
         * ```
         */
        useQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthWhoamiError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthWhoami.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthWhoamiParameters, TData = GetAuthWhoamiData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthWhoamiData, GetAuthWhoamiError, OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiData, ServiceOperationInfiniteQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthWhoamiData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthWhoamiParameters>, GetAuthWhoamiError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthWhoamiSchema, GetAuthWhoamiParameters, GetAuthWhoamiData, GetAuthWhoamiError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthWhoamiData, GetAuthWhoamiError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthWhoamiData>(parameters: ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters> | (GetAuthWhoamiParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthWhoamiData, GetAuthWhoamiError, TData, ServiceOperationQueryKey<GetAuthWhoamiSchema, GetAuthWhoamiParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthWhoamiError | Error>;
        schema: GetAuthWhoamiSchema;
        types: {
            parameters: GetAuthWhoamiParameters;
            data: GetAuthWhoamiData;
            error: GetAuthWhoamiError;
        };
    };
    getAuthMe: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetAuthMeParameters | void): ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): UseQueryResult<TData, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthMeError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetAuthMeParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, TPageParam, GetAuthMeError>): Promise<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetAuthMeParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, TPageParam, GetAuthMeError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetAuthMeParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, TPageParam, GetAuthMeError>): Promise<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, GetAuthMeError> | void): Promise<GetAuthMeData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, GetAuthMeError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAuthMeSchema, GetAuthMeData, GetAuthMeParameters, GetAuthMeError> | void): Promise<GetAuthMeData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void)): OperationInfiniteData<GetAuthMeData, GetAuthMeParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>,
            data: NoInfer<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>,
            data: GetAuthMeData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void)): GetAuthMeData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void)): QueryState<GetAuthMeData, GetAuthMeError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetAuthMeParameters | ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | void): QueryState<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>, GetAuthMeError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetAuthMeSchema, GetAuthMeParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetAuthMeParameters, TMeta, TSignal> | void), client?: (schema: GetAuthMeSchema, options: {
            parameters: GetAuthMeParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetAuthMeData, GetAuthMeError>>): Promise<RequestFnResponse<GetAuthMeData, GetAuthMeError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetAuthMeParameters | ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>> | undefined, NoInfer<OperationInfiniteData<GetAuthMeData, GetAuthMeParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetAuthMeData, GetAuthMeParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>, updater: Updater<NoInfer<GetAuthMeData> | undefined, NoInfer<GetAuthMeData> | undefined>, options?: SetDataOptions): Array<GetAuthMeData | undefined>;
        /**/
        setQueryData(parameters: (GetAuthMeParameters | undefined) | ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>, updater: Updater<NoInfer<GetAuthMeData> | undefined, NoInfer<GetAuthMeData> | undefined>, options?: SetDataOptions): GetAuthMeData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetAuthMeParameters | void): ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthMe.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthMeParameters, TData = GetAuthMeData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetAuthMeData, GetAuthMeError, OperationInfiniteData<TData, GetAuthMeParameters>, ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthMeData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthMe.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetAuthMeParameters, TData = GetAuthMeData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetAuthMeData, GetAuthMeError, OperationInfiniteData<TData, GetAuthMeParameters>, ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthMeData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getAuthMeTotal = qraft.v1Service.getAuthMe.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError> | QueryFiltersByQueryKey<GetAuthMeSchema, GetAuthMeData, TInfinite, GetAuthMeParameters, GetAuthMeError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getAuthMeResults = qraft.v1Service.getAuthMe.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthMeResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getAuthMeCombinedResults = qraft.v1Service.getAuthMe.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getAuthMeCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetAuthMeSchema, GetAuthMeParameters, GetAuthMeData, GetAuthMeError>>, TCombinedResult = Array<UseQueryResult<GetAuthMeData, GetAuthMeError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetAuthMeData, GetAuthMeError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetAuthMeParameters | void): ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options?: Omit<UndefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): UseQueryResult<TData, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getAuthMe.useQuery()
         * ```
         */
        useQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<DefinedInitialDataOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetAuthMeError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuthMe.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetAuthMeParameters, TData = GetAuthMeData>(parameters: ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetAuthMeData, GetAuthMeError, OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeData, ServiceOperationInfiniteQueryKey<GetAuthMeSchema, GetAuthMeParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetAuthMeData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuthMeParameters>, GetAuthMeError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuthMeSchema, GetAuthMeParameters, GetAuthMeData, GetAuthMeError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetAuthMeData, GetAuthMeError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuthMeData, GetAuthMeError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetAuthMeData>(parameters: ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters> | (GetAuthMeParameters | void), options?: Omit<UseSuspenseQueryOptions<GetAuthMeData, GetAuthMeError, TData, ServiceOperationQueryKey<GetAuthMeSchema, GetAuthMeParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetAuthMeError | Error>;
        schema: GetAuthMeSchema;
        types: {
            parameters: GetAuthMeParameters;
            data: GetAuthMeData;
            error: GetAuthMeError;
        };
    };
    postCliDockerPush: {
        /**/
        getMutationKey(parameters: PostCliDockerPushParameters | void): ServiceOperationMutationKey<PostCliDockerPushSchema, PostCliDockerPushParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation({
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends PostCliDockerPushBody, TContext = unknown>(parameters: PostCliDockerPushParameters, options?: ServiceOperationUseMutationOptions<PostCliDockerPushSchema, PostCliDockerPushData, PostCliDockerPushParameters, TVariables, PostCliDockerPushError, TContext>): UseMutationResult<PostCliDockerPushData, PostCliDockerPushError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation({
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliDockerPush.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     header: {
         *         "x-api-key": xApiKey,
         *         "x-app-name": xAppName,
         *         "x-app-platform": xAppPlatform
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliDockerPushBody, PostCliDockerPushParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliDockerPushSchema, PostCliDockerPushData, PostCliDockerPushParameters, TVariables, PostCliDockerPushError, TContext>): UseMutationResult<PostCliDockerPushData, PostCliDockerPushError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliDockerPushTotal = qraft.v1Service.postCliDockerPush.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliDockerPushTotal = qraft.v1Service.postCliDockerPush.useIsMutating({
         *     parameters: {
         *         header: {
         *             "x-api-key": xApiKey,
         *             "x-app-name": xAppName,
         *             "x-app-platform": xAppPlatform
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext> | MutationFiltersByMutationKey<PostCliDockerPushSchema, PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext> | MutationFiltersByMutationKey<PostCliDockerPushSchema, PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliDockerPushBody, PostCliDockerPushParameters>, client?: (schema: PostCliDockerPushSchema, options: ServiceOperationMutationFnOptions<PostCliDockerPushBody, PostCliDockerPushParameters>) => Promise<RequestFnResponse<PostCliDockerPushData, PostCliDockerPushError>>): Promise<RequestFnResponse<PostCliDockerPushData, PostCliDockerPushError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliDockerPushPendingMutationVariables = qraft.v1Service.postCliDockerPush.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliDockerPushMutationData = qraft.v1Service.postCliDockerPush.useMutationState({
         *     filters: {
         *         parameters: {
         *             header: {
         *                 "x-api-key": xApiKey,
         *                 "x-app-name": xAppName,
         *                 "x-app-platform": xAppPlatform
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliDockerPushData, PostCliDockerPushError, MutationVariables<PostCliDockerPushBody, PostCliDockerPushParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext> | MutationFiltersByMutationKey<PostCliDockerPushSchema, PostCliDockerPushBody, PostCliDockerPushData, PostCliDockerPushParameters, PostCliDockerPushError, TContext>;
            select?: (mutation: Mutation<PostCliDockerPushData, PostCliDockerPushError, MutationVariables<PostCliDockerPushBody, PostCliDockerPushParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliDockerPushSchema;
        types: {
            parameters: PostCliDockerPushParameters;
            data: PostCliDockerPushData;
            error: PostCliDockerPushError;
            body: PostCliDockerPushBody;
        };
    };
    getCliRepos: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetCliReposParameters): ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options?: Omit<UndefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): UseQueryResult<TData, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<DefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliReposError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetCliReposParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, TPageParam, GetCliReposError>): Promise<OperationInfiniteData<GetCliReposData, GetCliReposParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetCliReposParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, TPageParam, GetCliReposError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetCliReposParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, TPageParam, GetCliReposError>): Promise<OperationInfiniteData<GetCliReposData, GetCliReposParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, GetCliReposError>): Promise<GetCliReposData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, GetCliReposError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetCliReposSchema, GetCliReposData, GetCliReposParameters, GetCliReposError>): Promise<GetCliReposData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters)): OperationInfiniteData<GetCliReposData, GetCliReposParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>,
            data: NoInfer<OperationInfiniteData<GetCliReposData, GetCliReposParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>,
            data: GetCliReposData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters)): GetCliReposData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters)): QueryState<GetCliReposData, GetCliReposError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetCliReposParameters | ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>): QueryState<OperationInfiniteData<GetCliReposData, GetCliReposParameters>, GetCliReposError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetCliReposSchema, GetCliReposParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetCliReposParameters, TMeta, TSignal>), client?: (schema: GetCliReposSchema, options: {
            parameters: GetCliReposParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetCliReposData, GetCliReposError>>): Promise<RequestFnResponse<GetCliReposData, GetCliReposError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetCliReposParameters | ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetCliReposData, GetCliReposParameters>> | undefined, NoInfer<OperationInfiniteData<GetCliReposData, GetCliReposParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetCliReposData, GetCliReposParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>, updater: Updater<NoInfer<GetCliReposData> | undefined, NoInfer<GetCliReposData> | undefined>, options?: SetDataOptions): Array<GetCliReposData | undefined>;
        /**/
        setQueryData(parameters: (GetCliReposParameters) | ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>, updater: Updater<NoInfer<GetCliReposData> | undefined, NoInfer<GetCliReposData> | undefined>, options?: SetDataOptions): GetCliReposData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetCliReposParameters): ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliRepos.useInfiniteQuery({
         *     query: {
         *         type: type
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             type: initialType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliReposParameters, TData = GetCliReposData>(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetCliReposData, GetCliReposError, OperationInfiniteData<TData, GetCliReposParameters>, ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliReposData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliRepos.useInfiniteQuery({
         *     query: {
         *         type: type
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             type: initialType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCliReposParameters, TData = GetCliReposData>(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetCliReposData, GetCliReposError, OperationInfiniteData<TData, GetCliReposParameters>, ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliReposData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getCliReposTotal = qraft.v1Service.getCliRepos.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getCliReposByParametersTotal = qraft.v1Service.getCliRepos.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             type: type
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError> | QueryFiltersByQueryKey<GetCliReposSchema, GetCliReposData, TInfinite, GetCliReposParameters, GetCliReposError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getCliReposResults = qraft.v1Service.getCliRepos.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 type: type1
         *             }
         *         },
         *         {
         *             query: {
         *                 type: type2
         *             }
         *         }
         *     ]
         * });
         * getCliReposResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCliReposCombinedResults = qraft.v1Service.getCliRepos.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 type: type1
         *             }
         *         },
         *         {
         *             query: {
         *                 type: type2
         *             }
         *         }
         *     ]
         * });
         * getCliReposCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetCliReposSchema, GetCliReposParameters, GetCliReposData, GetCliReposError>>, TCombinedResult = Array<UseQueryResult<GetCliReposData, GetCliReposError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetCliReposData, GetCliReposError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetCliReposParameters): ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options?: Omit<UndefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): UseQueryResult<TData, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getCliRepos.useQuery({
         *     query: {
         *         type: type
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<DefinedInitialDataOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCliReposError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCliRepos.useSuspenseInfiniteQuery({
         *     query: {
         *         type: type
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             type: initialType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetCliReposParameters, TData = GetCliReposData>(parameters: ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetCliReposData, GetCliReposError, OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposData, ServiceOperationInfiniteQueryKey<GetCliReposSchema, GetCliReposParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCliReposData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetCliReposParameters>, GetCliReposError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetCliReposSchema, GetCliReposParameters, GetCliReposData, GetCliReposError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetCliReposData, GetCliReposError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetCliReposData, GetCliReposError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetCliReposData>(parameters: ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters> | (GetCliReposParameters), options?: Omit<UseSuspenseQueryOptions<GetCliReposData, GetCliReposError, TData, ServiceOperationQueryKey<GetCliReposSchema, GetCliReposParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetCliReposError | Error>;
        schema: GetCliReposSchema;
        types: {
            parameters: GetCliReposParameters;
            data: GetCliReposData;
            error: GetCliReposError;
        };
    };
    postCliRepos: {
        /**/
        getMutationKey(parameters: PostCliReposParameters | void): ServiceOperationMutationKey<PostCliReposSchema, PostCliReposParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostCliReposBody, TContext = unknown>(parameters: PostCliReposParameters, options?: ServiceOperationUseMutationOptions<PostCliReposSchema, PostCliReposData, PostCliReposParameters, TVariables, PostCliReposError, TContext>): UseMutationResult<PostCliReposData, PostCliReposError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postCliRepos.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostCliReposBody, PostCliReposParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostCliReposSchema, PostCliReposData, PostCliReposParameters, TVariables, PostCliReposError, TContext>): UseMutationResult<PostCliReposData, PostCliReposError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postCliReposTotal = qraft.v1Service.postCliRepos.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postCliReposTotal = qraft.v1Service.postCliRepos.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext> | MutationFiltersByMutationKey<PostCliReposSchema, PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext> | MutationFiltersByMutationKey<PostCliReposSchema, PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostCliReposBody, PostCliReposParameters>, client?: (schema: PostCliReposSchema, options: ServiceOperationMutationFnOptions<PostCliReposBody, PostCliReposParameters>) => Promise<RequestFnResponse<PostCliReposData, PostCliReposError>>): Promise<RequestFnResponse<PostCliReposData, PostCliReposError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postCliReposPendingMutationVariables = qraft.v1Service.postCliRepos.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postCliReposMutationData = qraft.v1Service.postCliRepos.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostCliReposData, PostCliReposError, MutationVariables<PostCliReposBody, PostCliReposParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext> | MutationFiltersByMutationKey<PostCliReposSchema, PostCliReposBody, PostCliReposData, PostCliReposParameters, PostCliReposError, TContext>;
            select?: (mutation: Mutation<PostCliReposData, PostCliReposError, MutationVariables<PostCliReposBody, PostCliReposParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostCliReposSchema;
        types: {
            parameters: PostCliReposParameters;
            data: PostCliReposData;
            error: PostCliReposError;
            body: PostCliReposBody;
        };
    };
    getExample: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetExampleParameters): ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options?: Omit<UndefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): UseQueryResult<TData, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<DefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetExampleError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetExampleParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, TPageParam, GetExampleError>): Promise<OperationInfiniteData<GetExampleData, GetExampleParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetExampleParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, TPageParam, GetExampleError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetExampleParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetExampleSchema, GetExampleData, GetExampleParameters, TPageParam, GetExampleError>): Promise<OperationInfiniteData<GetExampleData, GetExampleParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, GetExampleError>): Promise<GetExampleData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetExampleSchema, GetExampleData, GetExampleParameters, GetExampleError>): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetExampleSchema, GetExampleData, GetExampleParameters, GetExampleError>): Promise<GetExampleData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters)): OperationInfiniteData<GetExampleData, GetExampleParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>,
            data: NoInfer<OperationInfiniteData<GetExampleData, GetExampleParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>,
            data: GetExampleData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters)): GetExampleData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters)): QueryState<GetExampleData, GetExampleError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetExampleParameters | ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>): QueryState<OperationInfiniteData<GetExampleData, GetExampleParameters>, GetExampleError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetExampleSchema, GetExampleParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetExampleParameters, TMeta, TSignal>), client?: (schema: GetExampleSchema, options: {
            parameters: GetExampleParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetExampleData, GetExampleError>>): Promise<RequestFnResponse<GetExampleData, GetExampleError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetExampleParameters | ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetExampleData, GetExampleParameters>> | undefined, NoInfer<OperationInfiniteData<GetExampleData, GetExampleParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetExampleData, GetExampleParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>, updater: Updater<NoInfer<GetExampleData> | undefined, NoInfer<GetExampleData> | undefined>, options?: SetDataOptions): Array<GetExampleData | undefined>;
        /**/
        setQueryData(parameters: (GetExampleParameters) | ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>, updater: Updater<NoInfer<GetExampleData> | undefined, NoInfer<GetExampleData> | undefined>, options?: SetDataOptions): GetExampleData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetExampleParameters): ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getExample.useInfiniteQuery({
         *     query: {
         *         name: name
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             name: initialName
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetExampleParameters, TData = GetExampleData>(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<UndefinedInitialDataInfiniteOptions<GetExampleData, GetExampleError, OperationInfiniteData<TData, GetExampleParameters>, ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetExampleData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetExampleParameters>, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getExample.useInfiniteQuery({
         *     query: {
         *         name: name
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             name: initialName
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetExampleParameters, TData = GetExampleData>(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<DefinedInitialDataInfiniteOptions<GetExampleData, GetExampleError, OperationInfiniteData<TData, GetExampleParameters>, ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetExampleData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetExampleParameters>, GetExampleError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getExampleTotal = qraft.v1Service.getExample.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getExampleByParametersTotal = qraft.v1Service.getExample.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             name: name
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError> | QueryFiltersByQueryKey<GetExampleSchema, GetExampleData, TInfinite, GetExampleParameters, GetExampleError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getExampleResults = qraft.v1Service.getExample.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 name: name1
         *             }
         *         },
         *         {
         *             query: {
         *                 name: name2
         *             }
         *         }
         *     ]
         * });
         * getExampleResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getExampleCombinedResults = qraft.v1Service.getExample.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 name: name1
         *             }
         *         },
         *         {
         *             query: {
         *                 name: name2
         *             }
         *         }
         *     ]
         * });
         * getExampleCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetExampleSchema, GetExampleParameters, GetExampleData, GetExampleError>>, TCombinedResult = Array<UseQueryResult<GetExampleData, GetExampleError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetExampleData, GetExampleError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetExampleParameters): ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options?: Omit<UndefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): UseQueryResult<TData, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getExample.useQuery({
         *     query: {
         *         name: name
         *     }
         * })
         * ```
         */
        useQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<DefinedInitialDataOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetExampleError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getExample.useSuspenseInfiniteQuery({
         *     query: {
         *         name: name
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             name: initialName
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetExampleParameters, TData = GetExampleData>(parameters: ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetExampleData, GetExampleError, OperationInfiniteData<TData, GetExampleParameters>, GetExampleData, ServiceOperationInfiniteQueryKey<GetExampleSchema, GetExampleParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetExampleData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetExampleParameters>, GetExampleError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetExampleSchema, GetExampleParameters, GetExampleData, GetExampleError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetExampleData, GetExampleError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetExampleData, GetExampleError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetExampleData>(parameters: ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters> | (GetExampleParameters), options?: Omit<UseSuspenseQueryOptions<GetExampleData, GetExampleError, TData, ServiceOperationQueryKey<GetExampleSchema, GetExampleParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetExampleError | Error>;
        schema: GetExampleSchema;
        types: {
            parameters: GetExampleParameters;
            data: GetExampleData;
            error: GetExampleError;
        };
    };
    getGithubGetInstallAppUrl: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetGithubGetInstallAppUrlParameters | void): ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, TPageParam, GetGithubGetInstallAppUrlError>): Promise<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, TPageParam, GetGithubGetInstallAppUrlError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetGithubGetInstallAppUrlParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, TPageParam, GetGithubGetInstallAppUrlError>): Promise<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | void): Promise<GetGithubGetInstallAppUrlData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | void): Promise<GetGithubGetInstallAppUrlData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void)): OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>,
            data: NoInfer<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>,
            data: GetGithubGetInstallAppUrlData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void)): GetGithubGetInstallAppUrlData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void)): QueryState<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetGithubGetInstallAppUrlParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | void): QueryState<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGithubGetInstallAppUrlParameters, TMeta, TSignal> | void), client?: (schema: GetGithubGetInstallAppUrlSchema, options: {
            parameters: GetGithubGetInstallAppUrlParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>): Promise<RequestFnResponse<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetGithubGetInstallAppUrlParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>> | undefined, NoInfer<OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>, updater: Updater<NoInfer<GetGithubGetInstallAppUrlData> | undefined, NoInfer<GetGithubGetInstallAppUrlData> | undefined>, options?: SetDataOptions): Array<GetGithubGetInstallAppUrlData | undefined>;
        /**/
        setQueryData(parameters: (GetGithubGetInstallAppUrlParameters | undefined) | ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, updater: Updater<NoInfer<GetGithubGetInstallAppUrlData> | undefined, NoInfer<GetGithubGetInstallAppUrlData> | undefined>, options?: SetDataOptions): GetGithubGetInstallAppUrlData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetGithubGetInstallAppUrlParameters | void): ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstallAppUrl.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters, TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstallAppUrlData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstallAppUrl.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters, TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstallAppUrlData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getGithubGetInstallAppUrlTotal = qraft.v1Service.getGithubGetInstallAppUrl.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError> | QueryFiltersByQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlData, TInfinite, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getGithubGetInstallAppUrlResults = qraft.v1Service.getGithubGetInstallAppUrl.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstallAppUrlResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getGithubGetInstallAppUrlCombinedResults = qraft.v1Service.getGithubGetInstallAppUrl.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstallAppUrlCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>, TCombinedResult = Array<UseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetGithubGetInstallAppUrlParameters | void): ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstallAppUrl.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstallAppUrl.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetGithubGetInstallAppUrlParameters, TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlData, ServiceOperationInfiniteQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstallAppUrlData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstallAppUrlParameters>, GetGithubGetInstallAppUrlError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters, GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetGithubGetInstallAppUrlData>(parameters: ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters> | (GetGithubGetInstallAppUrlParameters | void), options?: Omit<UseSuspenseQueryOptions<GetGithubGetInstallAppUrlData, GetGithubGetInstallAppUrlError, TData, ServiceOperationQueryKey<GetGithubGetInstallAppUrlSchema, GetGithubGetInstallAppUrlParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetGithubGetInstallAppUrlError | Error>;
        schema: GetGithubGetInstallAppUrlSchema;
        types: {
            parameters: GetGithubGetInstallAppUrlParameters;
            data: GetGithubGetInstallAppUrlData;
            error: GetGithubGetInstallAppUrlError;
        };
    };
    getGithubGetInstalledOrganizations: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetGithubGetInstalledOrganizationsParameters | void): ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, TPageParam, GetGithubGetInstalledOrganizationsError>): Promise<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, TPageParam, GetGithubGetInstalledOrganizationsError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetGithubGetInstalledOrganizationsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, TPageParam, GetGithubGetInstalledOrganizationsError>): Promise<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | void): Promise<GetGithubGetInstalledOrganizationsData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | void): Promise<GetGithubGetInstalledOrganizationsData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void)): OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>,
            data: NoInfer<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>,
            data: GetGithubGetInstalledOrganizationsData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void)): GetGithubGetInstalledOrganizationsData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void)): QueryState<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetGithubGetInstalledOrganizationsParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | void): QueryState<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGithubGetInstalledOrganizationsParameters, TMeta, TSignal> | void), client?: (schema: GetGithubGetInstalledOrganizationsSchema, options: {
            parameters: GetGithubGetInstalledOrganizationsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>): Promise<RequestFnResponse<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetGithubGetInstalledOrganizationsParameters | ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>> | undefined, NoInfer<OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>, updater: Updater<NoInfer<GetGithubGetInstalledOrganizationsData> | undefined, NoInfer<GetGithubGetInstalledOrganizationsData> | undefined>, options?: SetDataOptions): Array<GetGithubGetInstalledOrganizationsData | undefined>;
        /**/
        setQueryData(parameters: (GetGithubGetInstalledOrganizationsParameters | undefined) | ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, updater: Updater<NoInfer<GetGithubGetInstalledOrganizationsData> | undefined, NoInfer<GetGithubGetInstalledOrganizationsData> | undefined>, options?: SetDataOptions): GetGithubGetInstalledOrganizationsData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetGithubGetInstalledOrganizationsParameters | void): ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstalledOrganizations.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters, TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstalledOrganizationsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstalledOrganizations.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters, TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstalledOrganizationsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getGithubGetInstalledOrganizationsTotal = qraft.v1Service.getGithubGetInstalledOrganizations.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError> | QueryFiltersByQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsData, TInfinite, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getGithubGetInstalledOrganizationsResults = qraft.v1Service.getGithubGetInstalledOrganizations.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstalledOrganizationsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getGithubGetInstalledOrganizationsCombinedResults = qraft.v1Service.getGithubGetInstalledOrganizations.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubGetInstalledOrganizationsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>, TCombinedResult = Array<UseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetGithubGetInstalledOrganizationsParameters | void): ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): UseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubGetInstalledOrganizations.useQuery()
         * ```
         */
        useQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubGetInstalledOrganizations.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetGithubGetInstalledOrganizationsParameters, TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsData, ServiceOperationInfiniteQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubGetInstalledOrganizationsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubGetInstalledOrganizationsParameters>, GetGithubGetInstalledOrganizationsError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters, GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetGithubGetInstalledOrganizationsData>(parameters: ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters> | (GetGithubGetInstalledOrganizationsParameters | void), options?: Omit<UseSuspenseQueryOptions<GetGithubGetInstalledOrganizationsData, GetGithubGetInstalledOrganizationsError, TData, ServiceOperationQueryKey<GetGithubGetInstalledOrganizationsSchema, GetGithubGetInstalledOrganizationsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetGithubGetInstalledOrganizationsError | Error>;
        schema: GetGithubGetInstalledOrganizationsSchema;
        types: {
            parameters: GetGithubGetInstalledOrganizationsParameters;
            data: GetGithubGetInstalledOrganizationsData;
            error: GetGithubGetInstalledOrganizationsError;
        };
    };
    postGithubSetDeafultOrganization: {
        /**/
        getMutationKey(parameters: PostGithubSetDeafultOrganizationParameters | void): ServiceOperationMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostGithubSetDeafultOrganizationBody, TContext = unknown>(parameters: PostGithubSetDeafultOrganizationParameters, options?: ServiceOperationUseMutationOptions<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, TVariables, PostGithubSetDeafultOrganizationError, TContext>): UseMutationResult<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postGithubSetDeafultOrganization.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, TVariables, PostGithubSetDeafultOrganizationError, TContext>): UseMutationResult<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postGithubSetDeafultOrganizationTotal = qraft.v1Service.postGithubSetDeafultOrganization.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postGithubSetDeafultOrganizationTotal = qraft.v1Service.postGithubSetDeafultOrganization.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext> | MutationFiltersByMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext> | MutationFiltersByMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, client?: (schema: PostGithubSetDeafultOrganizationSchema, options: ServiceOperationMutationFnOptions<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>) => Promise<RequestFnResponse<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError>>): Promise<RequestFnResponse<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postGithubSetDeafultOrganizationPendingMutationVariables = qraft.v1Service.postGithubSetDeafultOrganization.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postGithubSetDeafultOrganizationMutationData = qraft.v1Service.postGithubSetDeafultOrganization.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError, MutationVariables<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext> | MutationFiltersByMutationKey<PostGithubSetDeafultOrganizationSchema, PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationParameters, PostGithubSetDeafultOrganizationError, TContext>;
            select?: (mutation: Mutation<PostGithubSetDeafultOrganizationData, PostGithubSetDeafultOrganizationError, MutationVariables<PostGithubSetDeafultOrganizationBody, PostGithubSetDeafultOrganizationParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostGithubSetDeafultOrganizationSchema;
        types: {
            parameters: PostGithubSetDeafultOrganizationParameters;
            data: PostGithubSetDeafultOrganizationData;
            error: PostGithubSetDeafultOrganizationError;
            body: PostGithubSetDeafultOrganizationBody;
        };
    };
    getGithubPlayground: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetGithubPlaygroundParameters | void): ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): UseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, TPageParam, GetGithubPlaygroundError>): Promise<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, TPageParam, GetGithubPlaygroundError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetGithubPlaygroundParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, TPageParam, GetGithubPlaygroundError>): Promise<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | void): Promise<GetGithubPlaygroundData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGithubPlaygroundSchema, GetGithubPlaygroundData, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | void): Promise<GetGithubPlaygroundData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void)): OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>,
            data: NoInfer<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>,
            data: GetGithubPlaygroundData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void)): GetGithubPlaygroundData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void)): QueryState<GetGithubPlaygroundData, GetGithubPlaygroundError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetGithubPlaygroundParameters | ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | void): QueryState<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGithubPlaygroundParameters, TMeta, TSignal> | void), client?: (schema: GetGithubPlaygroundSchema, options: {
            parameters: GetGithubPlaygroundParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetGithubPlaygroundData, GetGithubPlaygroundError>>): Promise<RequestFnResponse<GetGithubPlaygroundData, GetGithubPlaygroundError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetGithubPlaygroundParameters | ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>> | undefined, NoInfer<OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetGithubPlaygroundData, GetGithubPlaygroundParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>, updater: Updater<NoInfer<GetGithubPlaygroundData> | undefined, NoInfer<GetGithubPlaygroundData> | undefined>, options?: SetDataOptions): Array<GetGithubPlaygroundData | undefined>;
        /**/
        setQueryData(parameters: (GetGithubPlaygroundParameters | undefined) | ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, updater: Updater<NoInfer<GetGithubPlaygroundData> | undefined, NoInfer<GetGithubPlaygroundData> | undefined>, options?: SetDataOptions): GetGithubPlaygroundData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetGithubPlaygroundParameters | void): ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubPlayground.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters, TData = GetGithubPlaygroundData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, OperationInfiniteData<TData, GetGithubPlaygroundParameters>, ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubPlaygroundData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubPlayground.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters, TData = GetGithubPlaygroundData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, OperationInfiniteData<TData, GetGithubPlaygroundParameters>, ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubPlaygroundData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getGithubPlaygroundTotal = qraft.v1Service.getGithubPlayground.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError> | QueryFiltersByQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundData, TInfinite, GetGithubPlaygroundParameters, GetGithubPlaygroundError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getGithubPlaygroundResults = qraft.v1Service.getGithubPlayground.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubPlaygroundResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getGithubPlaygroundCombinedResults = qraft.v1Service.getGithubPlayground.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getGithubPlaygroundCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters, GetGithubPlaygroundData, GetGithubPlaygroundError>>, TCombinedResult = Array<UseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetGithubPlaygroundParameters | void): ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options?: Omit<UndefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): UseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getGithubPlayground.useQuery()
         * ```
         */
        useQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<DefinedInitialDataOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetGithubPlaygroundError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGithubPlayground.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetGithubPlaygroundParameters, TData = GetGithubPlaygroundData>(parameters: ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundData, ServiceOperationInfiniteQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetGithubPlaygroundData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGithubPlaygroundParameters>, GetGithubPlaygroundError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters, GetGithubPlaygroundData, GetGithubPlaygroundError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGithubPlaygroundData, GetGithubPlaygroundError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetGithubPlaygroundData>(parameters: ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters> | (GetGithubPlaygroundParameters | void), options?: Omit<UseSuspenseQueryOptions<GetGithubPlaygroundData, GetGithubPlaygroundError, TData, ServiceOperationQueryKey<GetGithubPlaygroundSchema, GetGithubPlaygroundParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetGithubPlaygroundError | Error>;
        schema: GetGithubPlaygroundSchema;
        types: {
            parameters: GetGithubPlaygroundParameters;
            data: GetGithubPlaygroundData;
            error: GetGithubPlaygroundError;
        };
    };
    postServers: {
        /**/
        getMutationKey(parameters: PostServersParameters | void): ServiceOperationMutationKey<PostServersSchema, PostServersParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PostServersBody, TContext = unknown>(parameters: PostServersParameters, options?: ServiceOperationUseMutationOptions<PostServersSchema, PostServersData, PostServersParameters, TVariables, PostServersError, TContext>): UseMutationResult<PostServersData, PostServersError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.postServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PostServersBody, PostServersParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PostServersSchema, PostServersData, PostServersParameters, TVariables, PostServersError, TContext>): UseMutationResult<PostServersData, PostServersError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const postServersTotal = qraft.v1Service.postServers.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const postServersTotal = qraft.v1Service.postServers.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext> | MutationFiltersByMutationKey<PostServersSchema, PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext> | MutationFiltersByMutationKey<PostServersSchema, PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PostServersBody, PostServersParameters>, client?: (schema: PostServersSchema, options: ServiceOperationMutationFnOptions<PostServersBody, PostServersParameters>) => Promise<RequestFnResponse<PostServersData, PostServersError>>): Promise<RequestFnResponse<PostServersData, PostServersError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const postServersPendingMutationVariables = qraft.v1Service.postServers.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const postServersMutationData = qraft.v1Service.postServers.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PostServersData, PostServersError, MutationVariables<PostServersBody, PostServersParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext> | MutationFiltersByMutationKey<PostServersSchema, PostServersBody, PostServersData, PostServersParameters, PostServersError, TContext>;
            select?: (mutation: Mutation<PostServersData, PostServersError, MutationVariables<PostServersBody, PostServersParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PostServersSchema;
        types: {
            parameters: PostServersParameters;
            data: PostServersData;
            error: PostServersError;
            body: PostServersBody;
        };
    };
    putServers: {
        /**/
        getMutationKey(parameters: PutServersParameters | void): ServiceOperationMutationKey<PutServersSchema, PutServersParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends PutServersBody, TContext = unknown>(parameters: PutServersParameters, options?: ServiceOperationUseMutationOptions<PutServersSchema, PutServersData, PutServersParameters, TVariables, PutServersError, TContext>): UseMutationResult<PutServersData, PutServersError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.v1Service.putServers.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<PutServersBody, PutServersParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<PutServersSchema, PutServersData, PutServersParameters, TVariables, PutServersError, TContext>): UseMutationResult<PutServersData, PutServersError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const putServersTotal = qraft.v1Service.putServers.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const putServersTotal = qraft.v1Service.putServers.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext> | MutationFiltersByMutationKey<PutServersSchema, PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext>): number;
        /**/
        isMutating<TContext>(filters?: MutationFiltersByParameters<PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext> | MutationFiltersByMutationKey<PutServersSchema, PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext>): number;
        /**/
        (options: ServiceOperationMutationFnOptions<PutServersBody, PutServersParameters>, client?: (schema: PutServersSchema, options: ServiceOperationMutationFnOptions<PutServersBody, PutServersParameters>) => Promise<RequestFnResponse<PutServersData, PutServersError>>): Promise<RequestFnResponse<PutServersData, PutServersError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const putServersPendingMutationVariables = qraft.v1Service.putServers.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const putServersMutationData = qraft.v1Service.putServers.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<PutServersData, PutServersError, MutationVariables<PutServersBody, PutServersParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext> | MutationFiltersByMutationKey<PutServersSchema, PutServersBody, PutServersData, PutServersParameters, PutServersError, TContext>;
            select?: (mutation: Mutation<PutServersData, PutServersError, MutationVariables<PutServersBody, PutServersParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: PutServersSchema;
        types: {
            parameters: PutServersParameters;
            data: PutServersData;
            error: PutServersError;
            body: PutServersBody;
        };
    };
    get: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetParameters | void): ServiceOperationQueryKey<GetSchema, GetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options?: Omit<UndefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): UseQueryResult<TData, GetError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<DefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetSchema, GetData, GetParameters, TPageParam, GetError>): Promise<OperationInfiniteData<GetData, GetParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetSchema, GetData, GetParameters, TPageParam, GetError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetSchema, GetData, GetParameters, TPageParam, GetError>): Promise<OperationInfiniteData<GetData, GetParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetSchema, GetData, GetParameters, GetError> | void): Promise<GetData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetSchema, GetData, GetParameters, GetError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetSchema, GetData, GetParameters, GetError> | void): Promise<GetData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void)): OperationInfiniteData<GetData, GetParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>,
            data: NoInfer<OperationInfiniteData<GetData, GetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetSchema, GetParameters>,
            data: GetData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void)): GetData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void)): QueryState<GetData, GetError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetParameters | ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | void): QueryState<OperationInfiniteData<GetData, GetParameters>, GetError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetSchema, GetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetParameters, TMeta, TSignal> | void), client?: (schema: GetSchema, options: {
            parameters: GetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetData, GetError>>): Promise<RequestFnResponse<GetData, GetError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetParameters | ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetData, GetParameters>> | undefined, NoInfer<OperationInfiniteData<GetData, GetParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetData, GetParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>, updater: Updater<NoInfer<GetData> | undefined, NoInfer<GetData> | undefined>, options?: SetDataOptions): Array<GetData | undefined>;
        /**/
        setQueryData(parameters: (GetParameters | undefined) | ServiceOperationQueryKey<GetSchema, GetParameters>, updater: Updater<NoInfer<GetData> | undefined, NoInfer<GetData> | undefined>, options?: SetDataOptions): GetData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetParameters | void): ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.get.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetParameters, TData = GetData>(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetData, GetError, OperationInfiniteData<TData, GetParameters>, ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetParameters>, GetError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.get.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetParameters, TData = GetData>(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetData, GetError, OperationInfiniteData<TData, GetParameters>, ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetParameters>, GetError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getTotal = qraft.v1Service.get.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetSchema, GetData, TInfinite, GetParameters, GetError> | QueryFiltersByQueryKey<GetSchema, GetData, TInfinite, GetParameters, GetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getResults = qraft.v1Service.get.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCombinedResults = qraft.v1Service.get.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetSchema, GetParameters, GetData, GetError>>, TCombinedResult = Array<UseQueryResult<GetData, GetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetData, GetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetParameters | void): ServiceOperationQueryKey<GetSchema, GetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options?: Omit<UndefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): UseQueryResult<TData, GetError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.get.useQuery()
         * ```
         */
        useQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<DefinedInitialDataOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.get.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetParameters, TData = GetData>(parameters: ServiceOperationInfiniteQueryKey<GetSchema, GetParameters> | (GetParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetData, GetError, OperationInfiniteData<TData, GetParameters>, GetData, ServiceOperationInfiniteQueryKey<GetSchema, GetParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetParameters>, GetError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetSchema, GetParameters, GetData, GetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetData, GetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetData, GetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetData>(parameters: ServiceOperationQueryKey<GetSchema, GetParameters> | (GetParameters | void), options?: Omit<UseSuspenseQueryOptions<GetData, GetError, TData, ServiceOperationQueryKey<GetSchema, GetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetError | Error>;
        schema: GetSchema;
        types: {
            parameters: GetParameters;
            data: GetData;
            error: GetError;
        };
    };
    getUsers: {
        /**/
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: CancelOptions): Promise<void>;
        /**/
        getQueryKey(parameters: GetUsersParameters | void): ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options?: Omit<UndefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): UseQueryResult<TData, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<DefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetUsersError | Error>;
        /**/
        fetchInfiniteQuery<TPageParam extends GetUsersParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, TPageParam, GetUsersError>): Promise<OperationInfiniteData<GetUsersData, GetUsersParameters>>;
        /**/
        prefetchInfiniteQuery<TPageParam extends GetUsersParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, TPageParam, GetUsersError>): Promise<void>;
        /**/
        ensureInfiniteQueryData<TPageParam extends GetUsersParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetUsersSchema, GetUsersData, GetUsersParameters, TPageParam, GetUsersError>): Promise<OperationInfiniteData<GetUsersData, GetUsersParameters>>;
        /**/
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, GetUsersError> | void): Promise<GetUsersData>;
        /**/
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetUsersSchema, GetUsersData, GetUsersParameters, GetUsersError> | void): Promise<void>;
        /**/
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetUsersSchema, GetUsersData, GetUsersParameters, GetUsersError> | void): Promise<GetUsersData>;
        /**/
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void)): OperationInfiniteData<GetUsersData, GetUsersParameters> | undefined;
        /**/
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>,
            data: NoInfer<OperationInfiniteData<GetUsersData, GetUsersParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>,
            data: GetUsersData | undefined
        ]>;
        /**/
        getQueryData(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void)): GetUsersData | undefined;
        /**/
        getQueryState(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void)): QueryState<GetUsersData, GetUsersError> | undefined;
        /**/
        getInfiniteQueryState(parameters: GetUsersParameters | ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | void): QueryState<OperationInfiniteData<GetUsersData, GetUsersParameters>, GetUsersError> | undefined;
        /**/
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: InvalidateOptions): Promise<void>;
        /**/
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): number;
        /**/
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetUsersSchema, GetUsersParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetUsersParameters, TMeta, TSignal> | void), client?: (schema: GetUsersSchema, options: {
            parameters: GetUsersParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetUsersData, GetUsersError>>): Promise<RequestFnResponse<GetUsersData, GetUsersError>>;
        /**/
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: RefetchOptions): Promise<void>;
        /**/
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): void;
        /**/
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, options?: ResetOptions): Promise<void>;
        /**/
        setInfiniteQueryData(parameters: GetUsersParameters | ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetUsersData, GetUsersParameters>> | undefined, NoInfer<OperationInfiniteData<GetUsersData, GetUsersParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetUsersData, GetUsersParameters> | undefined;
        /**/
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>, updater: Updater<NoInfer<GetUsersData> | undefined, NoInfer<GetUsersData> | undefined>, options?: SetDataOptions): Array<GetUsersData | undefined>;
        /**/
        setQueryData(parameters: (GetUsersParameters | undefined) | ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>, updater: Updater<NoInfer<GetUsersData> | undefined, NoInfer<GetUsersData> | undefined>, options?: SetDataOptions): GetUsersData | undefined;
        /**/
        getInfiniteQueryKey(parameters: GetUsersParameters | void): ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsers.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUsersParameters, TData = GetUsersData>(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<GetUsersData, GetUsersError, OperationInfiniteData<TData, GetUsersParameters>, ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUsersData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, GetUsersParameters>, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsers.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUsersParameters, TData = GetUsersData>(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<GetUsersData, GetUsersError, OperationInfiniteData<TData, GetUsersParameters>, ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUsersData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, GetUsersParameters>, GetUsersError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getUsersTotal = qraft.v1Service.getUsers.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError> | QueryFiltersByQueryKey<GetUsersSchema, GetUsersData, TInfinite, GetUsersParameters, GetUsersError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getUsersResults = qraft.v1Service.getUsers.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getUsersResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getUsersCombinedResults = qraft.v1Service.getUsers.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getUsersCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetUsersSchema, GetUsersParameters, GetUsersData, GetUsersError>>, TCombinedResult = Array<UseQueryResult<GetUsersData, GetUsersError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetUsersData, GetUsersError>>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        getQueryKey(parameters: GetUsersParameters | void): ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options?: Omit<UndefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): UseQueryResult<TData, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.v1Service.getUsers.useQuery()
         * ```
         */
        useQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<DefinedInitialDataOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetUsersError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsers.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetUsersParameters, TData = GetUsersData>(parameters: ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetUsersData, GetUsersError, OperationInfiniteData<TData, GetUsersParameters>, GetUsersData, ServiceOperationInfiniteQueryKey<GetUsersSchema, GetUsersParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUsersData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUsersParameters>, GetUsersError | Error>;
        /**/
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUsersSchema, GetUsersParameters, GetUsersData, GetUsersError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetUsersData, GetUsersError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUsersData, GetUsersError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**/
        useSuspenseQuery<TData = GetUsersData>(parameters: ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters> | (GetUsersParameters | void), options?: Omit<UseSuspenseQueryOptions<GetUsersData, GetUsersError, TData, ServiceOperationQueryKey<GetUsersSchema, GetUsersParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetUsersError | Error>;
        schema: GetUsersSchema;
        types: {
            parameters: GetUsersParameters;
            data: GetUsersData;
            error: GetUsersError;
        };
    };
}
export const v1Service: {
    getAuthLogin: {
        schema: {
            method: "get";
            url: "/v1/auth/login";
        };
    };
    getAuthCloseWindowMessage: {
        schema: {
            method: "get";
            url: "/v1/auth/close-window-message";
        };
    };
    getAuthLogout: {
        schema: {
            method: "get";
            url: "/v1/auth/logout";
        };
    };
    getAuthWhoami: {
        schema: {
            method: "get";
            url: "/v1/auth/whoami";
        };
    };
    getAuthMe: {
        schema: {
            method: "get";
            url: "/v1/auth/me";
        };
    };
    postCliDockerPush: {
        schema: {
            method: "post";
            url: "/v1/cli/docker/push";
        };
    };
    getCliRepos: {
        schema: {
            method: "get";
            url: "/v1/cli/repos";
        };
    };
    postCliRepos: {
        schema: {
            method: "post";
            url: "/v1/cli/repos";
            mediaType: [
                "application/json"
            ];
        };
    };
    getExample: {
        schema: {
            method: "get";
            url: "/v1/example";
        };
    };
    getGithubGetInstallAppUrl: {
        schema: {
            method: "get";
            url: "/v1/github/get-install-app-url";
        };
    };
    getGithubGetInstalledOrganizations: {
        schema: {
            method: "get";
            url: "/v1/github/get-installed-organizations";
        };
    };
    postGithubSetDeafultOrganization: {
        schema: {
            method: "post";
            url: "/v1/github/set-deafult-organization";
            mediaType: [
                "application/json"
            ];
        };
    };
    getGithubPlayground: {
        schema: {
            method: "get";
            url: "/v1/github/playground";
        };
    };
    postServers: {
        schema: {
            method: "post";
            url: "/v1/servers";
        };
    };
    putServers: {
        schema: {
            method: "put";
            url: "/v1/servers";
            mediaType: [
                "application/json"
            ];
        };
    };
    get: {
        schema: {
            method: "get";
            url: "/v1";
        };
    };
    getUsers: {
        schema: {
            method: "get";
            url: "/v1/users";
        };
    };
} = {
    getAuthLogin: {
        schema: {
            method: "get",
            url: "/v1/auth/login"
        }
    },
    getAuthCloseWindowMessage: {
        schema: {
            method: "get",
            url: "/v1/auth/close-window-message"
        }
    },
    getAuthLogout: {
        schema: {
            method: "get",
            url: "/v1/auth/logout"
        }
    },
    getAuthWhoami: {
        schema: {
            method: "get",
            url: "/v1/auth/whoami"
        }
    },
    getAuthMe: {
        schema: {
            method: "get",
            url: "/v1/auth/me"
        }
    },
    postCliDockerPush: {
        schema: {
            method: "post",
            url: "/v1/cli/docker/push"
        }
    },
    getCliRepos: {
        schema: {
            method: "get",
            url: "/v1/cli/repos"
        }
    },
    postCliRepos: {
        schema: {
            method: "post",
            url: "/v1/cli/repos",
            mediaType: ["application/json"]
        }
    },
    getExample: {
        schema: {
            method: "get",
            url: "/v1/example"
        }
    },
    getGithubGetInstallAppUrl: {
        schema: {
            method: "get",
            url: "/v1/github/get-install-app-url"
        }
    },
    getGithubGetInstalledOrganizations: {
        schema: {
            method: "get",
            url: "/v1/github/get-installed-organizations"
        }
    },
    postGithubSetDeafultOrganization: {
        schema: {
            method: "post",
            url: "/v1/github/set-deafult-organization",
            mediaType: ["application/json"]
        }
    },
    getGithubPlayground: {
        schema: {
            method: "get",
            url: "/v1/github/playground"
        }
    },
    postServers: {
        schema: {
            method: "post",
            url: "/v1/servers"
        }
    },
    putServers: {
        schema: {
            method: "put",
            url: "/v1/servers",
            mediaType: ["application/json"]
        }
    },
    get: {
        schema: {
            method: "get",
            url: "/v1"
        }
    },
    getUsers: {
        schema: {
            method: "get",
            url: "/v1/users"
        }
    }
};
type GetAuthLoginSchema = {
    method: "get";
    url: "/v1/auth/login";
};
type GetAuthLoginParameters = undefined;
type GetAuthLoginData = unknown;
type GetAuthLoginError = unknown;
type GetAuthCloseWindowMessageSchema = {
    method: "get";
    url: "/v1/auth/close-window-message";
};
type GetAuthCloseWindowMessageParameters = undefined;
type GetAuthCloseWindowMessageData = paths["/v1/auth/close-window-message"]["get"]["responses"]["200"]["content"]["text/plain"];
type GetAuthCloseWindowMessageError = unknown;
type GetAuthLogoutSchema = {
    method: "get";
    url: "/v1/auth/logout";
};
type GetAuthLogoutParameters = undefined;
type GetAuthLogoutData = unknown;
type GetAuthLogoutError = unknown;
type GetAuthWhoamiSchema = {
    method: "get";
    url: "/v1/auth/whoami";
};
type GetAuthWhoamiParameters = undefined;
type GetAuthWhoamiData = unknown;
type GetAuthWhoamiError = unknown;
type GetAuthMeSchema = {
    method: "get";
    url: "/v1/auth/me";
};
type GetAuthMeParameters = undefined;
type GetAuthMeData = paths["/v1/auth/me"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAuthMeError = unknown;
type PostCliDockerPushSchema = {
    method: "post";
    url: "/v1/cli/docker/push";
};
type PostCliDockerPushParameters = paths["/v1/cli/docker/push"]["post"]["parameters"];
type PostCliDockerPushData = unknown;
type PostCliDockerPushError = unknown;
type PostCliDockerPushBody = undefined;
type GetCliReposSchema = {
    method: "get";
    url: "/v1/cli/repos";
};
type GetCliReposParameters = paths["/v1/cli/repos"]["get"]["parameters"];
type GetCliReposData = paths["/v1/cli/repos"]["get"]["responses"]["200"]["content"]["application/json"];
type GetCliReposError = unknown;
type PostCliReposSchema = {
    method: "post";
    url: "/v1/cli/repos";
    mediaType: [
        "application/json"
    ];
};
type PostCliReposParameters = {};
type PostCliReposData = paths["/v1/cli/repos"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCliReposError = unknown;
type PostCliReposBody = NonNullable<paths["/v1/cli/repos"]["post"]["requestBody"]>["content"]["application/json"];
type GetExampleSchema = {
    method: "get";
    url: "/v1/example";
};
type GetExampleParameters = paths["/v1/example"]["get"]["parameters"];
type GetExampleData = paths["/v1/example"]["get"]["responses"]["200"]["content"]["application/json"];
type GetExampleError = unknown;
type GetGithubGetInstallAppUrlSchema = {
    method: "get";
    url: "/v1/github/get-install-app-url";
};
type GetGithubGetInstallAppUrlParameters = undefined;
type GetGithubGetInstallAppUrlData = paths["/v1/github/get-install-app-url"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGithubGetInstallAppUrlError = unknown;
type GetGithubGetInstalledOrganizationsSchema = {
    method: "get";
    url: "/v1/github/get-installed-organizations";
};
type GetGithubGetInstalledOrganizationsParameters = undefined;
type GetGithubGetInstalledOrganizationsData = paths["/v1/github/get-installed-organizations"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGithubGetInstalledOrganizationsError = unknown;
type PostGithubSetDeafultOrganizationSchema = {
    method: "post";
    url: "/v1/github/set-deafult-organization";
    mediaType: [
        "application/json"
    ];
};
type PostGithubSetDeafultOrganizationParameters = {};
type PostGithubSetDeafultOrganizationData = unknown;
type PostGithubSetDeafultOrganizationError = unknown;
type PostGithubSetDeafultOrganizationBody = NonNullable<paths["/v1/github/set-deafult-organization"]["post"]["requestBody"]>["content"]["application/json"];
type GetGithubPlaygroundSchema = {
    method: "get";
    url: "/v1/github/playground";
};
type GetGithubPlaygroundParameters = undefined;
type GetGithubPlaygroundData = unknown;
type GetGithubPlaygroundError = unknown;
type PostServersSchema = {
    method: "post";
    url: "/v1/servers";
};
type PostServersParameters = {};
type PostServersData = unknown;
type PostServersError = unknown;
type PostServersBody = undefined;
type PutServersSchema = {
    method: "put";
    url: "/v1/servers";
    mediaType: [
        "application/json"
    ];
};
type PutServersParameters = {};
type PutServersData = unknown;
type PutServersError = unknown;
type PutServersBody = NonNullable<paths["/v1/servers"]["put"]["requestBody"]>["content"]["application/json"];
type GetSchema = {
    method: "get";
    url: "/v1";
};
type GetParameters = undefined;
type GetData = paths["/v1"]["get"]["responses"]["200"]["content"]["text/plain"];
type GetError = unknown;
type GetUsersSchema = {
    method: "get";
    url: "/v1/users";
};
type GetUsersParameters = undefined;
type GetUsersData = paths["/v1/users"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUsersError = unknown;
